<div style='display: none'>
@tableofcontents @section README

To view this file in the Firefox web browser, download readmeviewer.html from https://www.genivia.com/files/readmeviewer.html.zip, unzip and copy it to the same directory where this soapReadme.md file is located, then open it in Firefox to view the contents of soapReadme.md.

This markdown file is compatible with Doxygen.
</div>

## Overview {#doc-overview}

This report was generated by soapcpp2 v2.8.96 for interface header file [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) with options -r -c++ -C -L -w 

### Tools

The **wsdl2h** command line tool takes a set of WSDL and XSD files to generate a data binding interface header file.  This interface header file is similar to a C/C++ header file and contains declarations of C/C++ types and functions with explanatory comments, directives, and annotations.  Types are declared in this interface header file as serializable.  Functions are declared as Web service operations for the client and server sides.

The **soapcpp2** command line tool takes an interface header file (i.e. a header file) such as [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) to generate the data binding implementation.  This implementation includes XML serializers and source code for the client and server side.  An interface header file for soapcpp2 can be a regular C/C++ header file with type and function declarations (without code), and include annotations to declare XML schema-related properties.

### Files

The following c++ source code files were generated by soapcpp2 for interface header file [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h):

- [soapStub.h](.\lib\gsoap\gsoap\bin\win32\soapStub.h) contains an annotated copy of [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) and of the imported files (if any), where most of the information in this report [soapReadme.md](.\lib\gsoap\gsoap\bin\win32\soapReadme.md) is sourced from (this header file also #includes "stdsoap2.h")
- [soapH.h](.\lib\gsoap\gsoap\bin\win32\soapH.h) declares allocation and (de)serialization functions for each C/C++ type, to #include in projects (this header file also #includes "soapStub.h")
- [soapC.cpp](.\lib\gsoap\gsoap\bin\win32\soapC.cpp) defines allocation and (de)serialization functions for each C/C++ type, to compile with a project
- [soapClient.cpp](.\lib\gsoap\gsoap\bin\win32\soapClient.cpp) defines client call stub functions for service invocation, to compile with a project

Also compile stdsoap2.cpp (and dom.cpp if XML DOM is used) with a project (or link libgsoapssl++.a) and use the following compile-time options:

- `-DWITH_OPENSSL` to enable HTTPS with OpenSSL
- `-DWITH_GNUTLS` to enable HTTPS with GNUTLS
- `-DWITH_DOM` is required when using the WS-Security plugin
- `-DWITH_GZIP` to enable message compression

See the gSOAP documentation for additional options.

### Contents

This report has the following contents describing the data binding interface types, and the client- and the server-side operations (if any):

- [class, struct and union types](#doc-classes)
- [typedefs](#doc-typedefs)
- [summary of serializable types](#doc-types)
- [schemas and namespaces](#doc-namespaces)
- [Web client operations](#doc-client) lists the service operations to call

[![][1] To top](#)


## Class, Struct and Union Types {#doc-classes}

The table below lists the classes, structs and unions declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) or that are imported:

<table class="doxtable">
<tr><th> Type </th><th> Declared </th><th> Serializable </th></tr>
<tr><td><code><a href="#xsd__anyType"> xsd__anyType </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:159 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:166 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__ID__"> xsd__ID__ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:184 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__IDREF__"> xsd__IDREF__ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:194 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__QName_"> xsd__QName_ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:201 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__anyURI__"> xsd__anyURI__ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:211 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__base64Binary__"> xsd__base64Binary__ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:218 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__boolean_"> xsd__boolean_ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:225 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__byte__"> xsd__byte__ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:232 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__dateTime_"> xsd__dateTime_ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:239 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__decimal__"> xsd__decimal__ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:249 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__double_"> xsd__double_ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:256 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__duration__"> xsd__duration__ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:266 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__float_"> xsd__float_ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:273 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__int_"> xsd__int_ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:280 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__long_"> xsd__long_ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:287 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__short_"> xsd__short_ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:294 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__string_"> xsd__string_ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:301 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__unsignedByte__"> xsd__unsignedByte__ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:308 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__unsignedInt_"> xsd__unsignedInt_ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:315 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__unsignedLong_"> xsd__unsignedLong_ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:322 </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__unsignedShort_"> xsd__unsignedShort_ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:329 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__char__"> ns2__char__ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:419 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__duration__"> ns2__duration__ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:433 </td><td> yes </td></tr>
<tr><td><code><a href="#ns2__guid__"> ns2__guid__ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:446 </td><td> yes </td></tr>
<tr><td><code><a href="#ns5__StreamBody__"> ns5__StreamBody__ </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:482 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns1__Sign"> _ns1__Sign </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:342 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns1__SignResponse"> _ns1__SignResponse </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:344 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns1__Journal"> _ns1__Journal </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:346 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns1__JournalResponse"> _ns1__JournalResponse </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:348 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns1__Echo"> _ns1__Echo </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:350 </td><td> yes </td></tr>
<tr><td><code><a href="#_ns1__EchoResponse"> _ns1__EchoResponse </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:352 </td><td> yes </td></tr>
<tr><td><code><a href="#ns3__ReceiptRequest"> ns3__ReceiptRequest </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:354 </td><td> yes </td></tr>
<tr><td><code><a href="#ns3__ArrayOfChargeItem"> ns3__ArrayOfChargeItem </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:356 </td><td> yes </td></tr>
<tr><td><code><a href="#ns3__ChargeItem"> ns3__ChargeItem </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:358 </td><td> yes </td></tr>
<tr><td><code><a href="#ns3__ArrayOfPayItem"> ns3__ArrayOfPayItem </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:360 </td><td> yes </td></tr>
<tr><td><code><a href="#ns3__PayItem"> ns3__PayItem </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:362 </td><td> yes </td></tr>
<tr><td><code><a href="#ns3__ReceiptResponse"> ns3__ReceiptResponse </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:364 </td><td> yes </td></tr>
<tr><td><code><a href="#ns3__ArrayOfSignaturItem"> ns3__ArrayOfSignaturItem </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:366 </td><td> yes </td></tr>
<tr><td><code><a href="#ns3__SignaturItem"> ns3__SignaturItem </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:368 </td><td> yes </td></tr>
<tr><td><code><a href="#ns4__ArrayOfstring"> ns4__ArrayOfstring </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:370 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__Sign"> struct __ns1__Sign </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:1273 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__Journal"> struct __ns1__Journal </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:1343 </td><td> yes </td></tr>
<tr><td><code><a href="#__ns1__Echo"> struct __ns1__Echo </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:1413 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Header"> struct SOAP_ENV__Header </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:1648 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Code"> struct SOAP_ENV__Code </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:1648 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Detail"> struct SOAP_ENV__Detail </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:1648 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Reason"> struct SOAP_ENV__Reason </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:1648 </td><td> yes </td></tr>
<tr><td><code><a href="#SOAP_ENV__Fault"> struct SOAP_ENV__Fault </a></code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:1648 </td><td> yes </td></tr>
</table>

<a name="xsd__anyType"></a>

### `xsd__anyType`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 159, is a simple content wrapper *`xsd:anyType`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anyType' wrapped by this struct
        char *__item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyType
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyType; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyType, default initialized and not managed by a soap context
        virtual xsd__anyType *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyType); }
      public:
        /// Constructor with default initializations
        xsd__anyType() : __item(), soap() { }
        virtual ~xsd__anyType() { }
        /// Friend allocator used by soap_new_xsd__anyType(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__ID__"> xsd__ID__ </a></code> is a derived class of this base class
- <code><a href="#xsd__IDREF__"> xsd__IDREF__ </a></code> is a derived class of this base class
- <code><a href="#xsd__QName_"> xsd__QName_ </a></code> is a derived class of this base class
- <code><a href="#xsd__anyURI__"> xsd__anyURI__ </a></code> is a derived class of this base class
- <code><a href="#xsd__base64Binary__"> xsd__base64Binary__ </a></code> is a derived class of this base class
- <code><a href="#xsd__boolean_"> xsd__boolean_ </a></code> is a derived class of this base class
- <code><a href="#xsd__byte__"> xsd__byte__ </a></code> is a derived class of this base class
- <code><a href="#xsd__dateTime_"> xsd__dateTime_ </a></code> is a derived class of this base class
- <code><a href="#xsd__decimal__"> xsd__decimal__ </a></code> is a derived class of this base class
- <code><a href="#xsd__double_"> xsd__double_ </a></code> is a derived class of this base class
- <code><a href="#xsd__duration__"> xsd__duration__ </a></code> is a derived class of this base class
- <code><a href="#xsd__float_"> xsd__float_ </a></code> is a derived class of this base class
- <code><a href="#xsd__int_"> xsd__int_ </a></code> is a derived class of this base class
- <code><a href="#xsd__long_"> xsd__long_ </a></code> is a derived class of this base class
- <code><a href="#xsd__short_"> xsd__short_ </a></code> is a derived class of this base class
- <code><a href="#xsd__string_"> xsd__string_ </a></code> is a derived class of this base class
- <code><a href="#xsd__unsignedByte__"> xsd__unsignedByte__ </a></code> is a derived class of this base class
- <code><a href="#xsd__unsignedInt_"> xsd__unsignedInt_ </a></code> is a derived class of this base class
- <code><a href="#xsd__unsignedLong_"> xsd__unsignedLong_ </a></code> is a derived class of this base class
- <code><a href="#xsd__unsignedShort_"> xsd__unsignedShort_ </a></code> is a derived class of this base class
- <code><a href="#ns2__char__"> ns2__char__ </a></code> is a derived class of this base class
- <code><a href="#ns2__duration__"> ns2__duration__ </a></code> is a derived class of this base class
- <code><a href="#ns2__guid__"> ns2__guid__ </a></code> is a derived class of this base class
- <code><a href="#ns5__StreamBody__"> ns5__StreamBody__ </a></code> is a derived class of this base class
- <code><a href="#ns3__ReceiptRequest"> ns3__ReceiptRequest </a></code> is a derived class of this base class
- <code><a href="#ns3__ArrayOfChargeItem"> ns3__ArrayOfChargeItem </a></code> is a derived class of this base class
- <code><a href="#ns3__ChargeItem"> ns3__ChargeItem </a></code> is a derived class of this base class
- <code><a href="#ns3__ArrayOfPayItem"> ns3__ArrayOfPayItem </a></code> is a derived class of this base class
- <code><a href="#ns3__PayItem"> ns3__PayItem </a></code> is a derived class of this base class
- <code><a href="#ns3__ReceiptResponse"> ns3__ReceiptResponse </a></code> is a derived class of this base class
- <code><a href="#ns3__ArrayOfSignaturItem"> ns3__ArrayOfSignaturItem </a></code> is a derived class of this base class
- <code><a href="#ns3__SignaturItem"> ns3__SignaturItem </a></code> is a derived class of this base class
- <code><a href="#ns4__ArrayOfstring"> ns4__ArrayOfstring </a></code> is a derived class of this base class
- `char *__item` is simple content of XML schema type *`xsd:anyType`* wrapped in *`xsd:anyType`*, where the type of this member is <code><a href="#_XML"> _XML </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)
- `struct soap *soap` the context that manages this object

The following operations on `xsd__anyType` are available:

- `xsd__anyType *soap_new_xsd__anyType(struct soap*)` managed allocation with default initialization
- `xsd__anyType *soap_new_xsd__anyType(struct soap*, int n)` managed allocation of array `xsd__anyType[n]`
- `xsd__anyType *soap_new_req_xsd__anyType(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__anyType *soap_new_set_xsd__anyType(struct soap*, char *__item)` managed allocation with public members assigned the values of these parameters
- `void xsd__anyType::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__anyType(struct soap*, const xsd__anyType*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__anyType(struct soap*, const char *URL, const xsd__anyType*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__anyType(struct soap*, const char *URL, const xsd__anyType*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__anyType(struct soap*, const char *URL, const xsd__anyType*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__anyType(struct soap*, xsd__anyType*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__anyType(struct soap*, const char *URL, xsd__anyType*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__anyType(struct soap*, xsd__anyType*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__base64Binary"></a>

### `xsd__base64Binary`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 166, is an attachment, meaning binary data attached as a MTOM/MIME/DIME attachment or included as *`xsd:base64Binary`* base64 with `__ptr` pointing to the data of length `__size` and `id`, `type`, and `options` identifying and describing the attachment data (use the `SOAP_ENC_MTOM` or the `SOAP_ENC_MIME` flag and set at least `type` to create an attachment ), and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__base64Binary {
      public:
        unsigned char *__ptr;
        int __size;
        /// Optional element 'id' of XML schema type 'xsd:string'
        char *id;
        /// Optional element 'type' of XML schema type 'xsd:string'
        char *type;
        /// Optional element 'options' of XML schema type 'xsd:string'
        char *options;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
        virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary() : __ptr(), __size(), id(), type(), options() { }
        virtual ~xsd__base64Binary() { }
        /// Friend allocator used by soap_new_xsd__base64Binary(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
    };

The following operations on `xsd__base64Binary` are available:

- `xsd__base64Binary *soap_new_xsd__base64Binary(struct soap*)` managed allocation with default initialization
- `xsd__base64Binary *soap_new_xsd__base64Binary(struct soap*, int n)` managed allocation of array `xsd__base64Binary[n]`
- `xsd__base64Binary *soap_new_req_xsd__base64Binary(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__base64Binary *soap_new_set_xsd__base64Binary(struct soap*, unsigned char *__ptr, int __size, char *id, char *type, char *options)` managed allocation with public members assigned the values of these parameters
- `void xsd__base64Binary::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__base64Binary(struct soap*, const xsd__base64Binary*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__base64Binary(struct soap*, const char *URL, const xsd__base64Binary*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__base64Binary(struct soap*, const char *URL, const xsd__base64Binary*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__base64Binary(struct soap*, const char *URL, const xsd__base64Binary*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__base64Binary(struct soap*, xsd__base64Binary*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__base64Binary(struct soap*, const char *URL, xsd__base64Binary*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__base64Binary(struct soap*, xsd__base64Binary*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__ID__"></a>

### `xsd__ID__`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 184, is a simple content wrapper *`xsd:ID`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__ID__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:ID' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__ID__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__ID__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__ID__, default initialized and not managed by a soap context
        virtual xsd__ID__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__ID__); }
      public:
        /// Constructor with default initializations
        xsd__ID__() : __item() { }
        virtual ~xsd__ID__() { }
        /// Friend allocator used by soap_new_xsd__ID__(struct soap*, int)
        friend SOAP_FMAC1 xsd__ID__ * SOAP_FMAC2 soap_instantiate_xsd__ID__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `char *__item` is simple content of XML schema type *`xsd:ID`* wrapped in *`xsd:ID`*, where the type of this member is <code><a href="#xsd__ID"> xsd__ID </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__ID__` are available:

- `xsd__ID__ *soap_new_xsd__ID__(struct soap*)` managed allocation with default initialization
- `xsd__ID__ *soap_new_xsd__ID__(struct soap*, int n)` managed allocation of array `xsd__ID__[n]`
- `xsd__ID__ *soap_new_req_xsd__ID__(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__ID__ *soap_new_set_xsd__ID__(struct soap*, char *__item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__ID__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__ID__(struct soap*, const xsd__ID__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__ID__(struct soap*, const char *URL, const xsd__ID__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__ID__(struct soap*, const char *URL, const xsd__ID__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__ID__(struct soap*, const char *URL, const xsd__ID__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__ID__(struct soap*, xsd__ID__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__ID__(struct soap*, const char *URL, xsd__ID__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__ID__(struct soap*, xsd__ID__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__IDREF__"></a>

### `xsd__IDREF__`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 194, is a simple content wrapper *`xsd:IDREF`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__IDREF__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:IDREF' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__IDREF__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__IDREF__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__IDREF__, default initialized and not managed by a soap context
        virtual xsd__IDREF__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__IDREF__); }
      public:
        /// Constructor with default initializations
        xsd__IDREF__() : __item() { }
        virtual ~xsd__IDREF__() { }
        /// Friend allocator used by soap_new_xsd__IDREF__(struct soap*, int)
        friend SOAP_FMAC1 xsd__IDREF__ * SOAP_FMAC2 soap_instantiate_xsd__IDREF__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `char *__item` is simple content of XML schema type *`xsd:IDREF`* wrapped in *`xsd:IDREF`*, where the type of this member is <code><a href="#xsd__IDREF"> xsd__IDREF </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__IDREF__` are available:

- `xsd__IDREF__ *soap_new_xsd__IDREF__(struct soap*)` managed allocation with default initialization
- `xsd__IDREF__ *soap_new_xsd__IDREF__(struct soap*, int n)` managed allocation of array `xsd__IDREF__[n]`
- `xsd__IDREF__ *soap_new_req_xsd__IDREF__(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__IDREF__ *soap_new_set_xsd__IDREF__(struct soap*, char *__item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__IDREF__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__IDREF__(struct soap*, const xsd__IDREF__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__IDREF__(struct soap*, const char *URL, const xsd__IDREF__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__IDREF__(struct soap*, const char *URL, const xsd__IDREF__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__IDREF__(struct soap*, const char *URL, const xsd__IDREF__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__IDREF__(struct soap*, xsd__IDREF__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__IDREF__(struct soap*, const char *URL, xsd__IDREF__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__IDREF__(struct soap*, xsd__IDREF__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__QName_"></a>

### `xsd__QName_`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 201, is a simple content wrapper *`xsd:QName`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__QName_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:QName' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__QName_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__QName_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__QName_, default initialized and not managed by a soap context
        virtual xsd__QName_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__QName_); }
      public:
        /// Constructor with default initializations
        xsd__QName_() : __item() { }
        virtual ~xsd__QName_() { }
        /// Friend allocator used by soap_new_xsd__QName_(struct soap*, int)
        friend SOAP_FMAC1 xsd__QName_ * SOAP_FMAC2 soap_instantiate_xsd__QName_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `char *__item` is simple content of XML schema type *`xsd:QName`* wrapped in *`xsd:QName`*, where the type of this member is <code><a href="#_QName"> _QName </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__QName_` are available:

- `xsd__QName_ *soap_new_xsd__QName_(struct soap*)` managed allocation with default initialization
- `xsd__QName_ *soap_new_xsd__QName_(struct soap*, int n)` managed allocation of array `xsd__QName_[n]`
- `xsd__QName_ *soap_new_req_xsd__QName_(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__QName_ *soap_new_set_xsd__QName_(struct soap*, char *__item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__QName_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__QName_(struct soap*, const xsd__QName_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__QName_(struct soap*, const char *URL, const xsd__QName_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__QName_(struct soap*, const char *URL, const xsd__QName_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__QName_(struct soap*, const char *URL, const xsd__QName_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__QName_(struct soap*, xsd__QName_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__QName_(struct soap*, const char *URL, xsd__QName_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__QName_(struct soap*, xsd__QName_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__anyURI__"></a>

### `xsd__anyURI__`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 211, is a simple content wrapper *`xsd:anyURI`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__anyURI__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:anyURI' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__anyURI__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__anyURI__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__anyURI__, default initialized and not managed by a soap context
        virtual xsd__anyURI__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__anyURI__); }
      public:
        /// Constructor with default initializations
        xsd__anyURI__() : __item() { }
        virtual ~xsd__anyURI__() { }
        /// Friend allocator used by soap_new_xsd__anyURI__(struct soap*, int)
        friend SOAP_FMAC1 xsd__anyURI__ * SOAP_FMAC2 soap_instantiate_xsd__anyURI__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `char *__item` is simple content of XML schema type *`xsd:anyURI`* wrapped in *`xsd:anyURI`*, where the type of this member is <code><a href="#xsd__anyURI"> xsd__anyURI </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__anyURI__` are available:

- `xsd__anyURI__ *soap_new_xsd__anyURI__(struct soap*)` managed allocation with default initialization
- `xsd__anyURI__ *soap_new_xsd__anyURI__(struct soap*, int n)` managed allocation of array `xsd__anyURI__[n]`
- `xsd__anyURI__ *soap_new_req_xsd__anyURI__(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__anyURI__ *soap_new_set_xsd__anyURI__(struct soap*, char *__item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__anyURI__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__anyURI__(struct soap*, const xsd__anyURI__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__anyURI__(struct soap*, const char *URL, const xsd__anyURI__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__anyURI__(struct soap*, const char *URL, const xsd__anyURI__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__anyURI__(struct soap*, const char *URL, const xsd__anyURI__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__anyURI__(struct soap*, xsd__anyURI__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__anyURI__(struct soap*, const char *URL, xsd__anyURI__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__anyURI__(struct soap*, xsd__anyURI__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__base64Binary__"></a>

### `xsd__base64Binary__`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 218, is a simple content wrapper *`xsd:base64Binary`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__base64Binary__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:base64Binary' wrapped by this struct
        xsd__base64Binary __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__base64Binary__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__base64Binary__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__base64Binary__, default initialized and not managed by a soap context
        virtual xsd__base64Binary__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__base64Binary__); }
      public:
        /// Constructor with default initializations
        xsd__base64Binary__() : __item() { }
        virtual ~xsd__base64Binary__() { }
        /// Friend allocator used by soap_new_xsd__base64Binary__(struct soap*, int)
        friend SOAP_FMAC1 xsd__base64Binary__ * SOAP_FMAC2 soap_instantiate_xsd__base64Binary__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `xsd__base64Binary __item` is simple content of XML schema type *`xsd:base64Binary`* wrapped in *`xsd:base64Binary`*, where the type of this member is <code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__base64Binary__` are available:

- `xsd__base64Binary__ *soap_new_xsd__base64Binary__(struct soap*)` managed allocation with default initialization
- `xsd__base64Binary__ *soap_new_xsd__base64Binary__(struct soap*, int n)` managed allocation of array `xsd__base64Binary__[n]`
- `xsd__base64Binary__ *soap_new_req_xsd__base64Binary__(struct soap*, const xsd__base64Binary& __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__base64Binary__ *soap_new_set_xsd__base64Binary__(struct soap*, const xsd__base64Binary& __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__base64Binary__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__base64Binary__(struct soap*, const xsd__base64Binary__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__base64Binary__(struct soap*, const char *URL, const xsd__base64Binary__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__base64Binary__(struct soap*, const char *URL, const xsd__base64Binary__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__base64Binary__(struct soap*, const char *URL, const xsd__base64Binary__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__base64Binary__(struct soap*, xsd__base64Binary__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__base64Binary__(struct soap*, const char *URL, xsd__base64Binary__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__base64Binary__(struct soap*, xsd__base64Binary__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__boolean_"></a>

### `xsd__boolean_`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 225, is a simple content wrapper *`xsd:boolean`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__boolean_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:boolean' wrapped by this struct
        bool __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__boolean_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__boolean_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__boolean_, default initialized and not managed by a soap context
        virtual xsd__boolean_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__boolean_); }
      public:
        /// Constructor with default initializations
        xsd__boolean_() : __item() { }
        virtual ~xsd__boolean_() { }
        /// Friend allocator used by soap_new_xsd__boolean_(struct soap*, int)
        friend SOAP_FMAC1 xsd__boolean_ * SOAP_FMAC2 soap_instantiate_xsd__boolean_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `bool __item` is simple content of XML schema type *`xsd:boolean`* wrapped in *`xsd:boolean`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__boolean_` are available:

- `xsd__boolean_ *soap_new_xsd__boolean_(struct soap*)` managed allocation with default initialization
- `xsd__boolean_ *soap_new_xsd__boolean_(struct soap*, int n)` managed allocation of array `xsd__boolean_[n]`
- `xsd__boolean_ *soap_new_req_xsd__boolean_(struct soap*, bool __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__boolean_ *soap_new_set_xsd__boolean_(struct soap*, bool __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__boolean_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__boolean_(struct soap*, const xsd__boolean_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__boolean_(struct soap*, const char *URL, const xsd__boolean_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__boolean_(struct soap*, const char *URL, const xsd__boolean_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__boolean_(struct soap*, const char *URL, const xsd__boolean_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__boolean_(struct soap*, xsd__boolean_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__boolean_(struct soap*, const char *URL, xsd__boolean_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__boolean_(struct soap*, xsd__boolean_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__byte__"></a>

### `xsd__byte__`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 232, is a simple content wrapper *`xsd:byte`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__byte__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:byte' wrapped by this struct
        char __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__byte__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__byte__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__byte__, default initialized and not managed by a soap context
        virtual xsd__byte__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__byte__); }
      public:
        /// Constructor with default initializations
        xsd__byte__() : __item() { }
        virtual ~xsd__byte__() { }
        /// Friend allocator used by soap_new_xsd__byte__(struct soap*, int)
        friend SOAP_FMAC1 xsd__byte__ * SOAP_FMAC2 soap_instantiate_xsd__byte__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `char __item` is simple content of XML schema type *`xsd:byte`* wrapped in *`xsd:byte`*, where the type of this member is <code><a href="#xsd__byte"> xsd__byte </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__byte__` are available:

- `xsd__byte__ *soap_new_xsd__byte__(struct soap*)` managed allocation with default initialization
- `xsd__byte__ *soap_new_xsd__byte__(struct soap*, int n)` managed allocation of array `xsd__byte__[n]`
- `xsd__byte__ *soap_new_req_xsd__byte__(struct soap*, char __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__byte__ *soap_new_set_xsd__byte__(struct soap*, char __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__byte__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__byte__(struct soap*, const xsd__byte__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__byte__(struct soap*, const char *URL, const xsd__byte__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__byte__(struct soap*, const char *URL, const xsd__byte__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__byte__(struct soap*, const char *URL, const xsd__byte__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__byte__(struct soap*, xsd__byte__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__byte__(struct soap*, const char *URL, xsd__byte__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__byte__(struct soap*, xsd__byte__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__dateTime_"></a>

### `xsd__dateTime_`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 239, is a simple content wrapper *`xsd:dateTime`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__dateTime_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:dateTime' wrapped by this struct
        time_t __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__dateTime_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__dateTime_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__dateTime_, default initialized and not managed by a soap context
        virtual xsd__dateTime_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__dateTime_); }
      public:
        /// Constructor with default initializations
        xsd__dateTime_() : __item() { }
        virtual ~xsd__dateTime_() { }
        /// Friend allocator used by soap_new_xsd__dateTime_(struct soap*, int)
        friend SOAP_FMAC1 xsd__dateTime_ * SOAP_FMAC2 soap_instantiate_xsd__dateTime_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `time_t __item` is simple content of XML schema type *`xsd:dateTime`* wrapped in *`xsd:dateTime`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__dateTime_` are available:

- `xsd__dateTime_ *soap_new_xsd__dateTime_(struct soap*)` managed allocation with default initialization
- `xsd__dateTime_ *soap_new_xsd__dateTime_(struct soap*, int n)` managed allocation of array `xsd__dateTime_[n]`
- `xsd__dateTime_ *soap_new_req_xsd__dateTime_(struct soap*, time_t __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__dateTime_ *soap_new_set_xsd__dateTime_(struct soap*, time_t __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__dateTime_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__dateTime_(struct soap*, const xsd__dateTime_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__dateTime_(struct soap*, const char *URL, const xsd__dateTime_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__dateTime_(struct soap*, const char *URL, const xsd__dateTime_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__dateTime_(struct soap*, const char *URL, const xsd__dateTime_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__dateTime_(struct soap*, xsd__dateTime_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__dateTime_(struct soap*, const char *URL, xsd__dateTime_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__dateTime_(struct soap*, xsd__dateTime_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__decimal__"></a>

### `xsd__decimal__`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 249, is a simple content wrapper *`xsd:decimal`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__decimal__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:decimal' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__decimal__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__decimal__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__decimal__, default initialized and not managed by a soap context
        virtual xsd__decimal__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__decimal__); }
      public:
        /// Constructor with default initializations
        xsd__decimal__() : __item() { }
        virtual ~xsd__decimal__() { }
        /// Friend allocator used by soap_new_xsd__decimal__(struct soap*, int)
        friend SOAP_FMAC1 xsd__decimal__ * SOAP_FMAC2 soap_instantiate_xsd__decimal__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `char *__item` is simple content of XML schema type *`xsd:decimal`* wrapped in *`xsd:decimal`*, where the type of this member is <code><a href="#xsd__decimal"> xsd__decimal </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__decimal__` are available:

- `xsd__decimal__ *soap_new_xsd__decimal__(struct soap*)` managed allocation with default initialization
- `xsd__decimal__ *soap_new_xsd__decimal__(struct soap*, int n)` managed allocation of array `xsd__decimal__[n]`
- `xsd__decimal__ *soap_new_req_xsd__decimal__(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__decimal__ *soap_new_set_xsd__decimal__(struct soap*, char *__item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__decimal__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__decimal__(struct soap*, const xsd__decimal__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__decimal__(struct soap*, const char *URL, const xsd__decimal__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__decimal__(struct soap*, const char *URL, const xsd__decimal__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__decimal__(struct soap*, const char *URL, const xsd__decimal__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__decimal__(struct soap*, xsd__decimal__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__decimal__(struct soap*, const char *URL, xsd__decimal__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__decimal__(struct soap*, xsd__decimal__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__double_"></a>

### `xsd__double_`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 256, is a simple content wrapper *`xsd:double`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__double_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:double' wrapped by this struct
        double __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__double_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__double_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__double_, default initialized and not managed by a soap context
        virtual xsd__double_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__double_); }
      public:
        /// Constructor with default initializations
        xsd__double_() : __item() { }
        virtual ~xsd__double_() { }
        /// Friend allocator used by soap_new_xsd__double_(struct soap*, int)
        friend SOAP_FMAC1 xsd__double_ * SOAP_FMAC2 soap_instantiate_xsd__double_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `double __item` is simple content of XML schema type *`xsd:double`* wrapped in *`xsd:double`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__double_` are available:

- `xsd__double_ *soap_new_xsd__double_(struct soap*)` managed allocation with default initialization
- `xsd__double_ *soap_new_xsd__double_(struct soap*, int n)` managed allocation of array `xsd__double_[n]`
- `xsd__double_ *soap_new_req_xsd__double_(struct soap*, double __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__double_ *soap_new_set_xsd__double_(struct soap*, double __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__double_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__double_(struct soap*, const xsd__double_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__double_(struct soap*, const char *URL, const xsd__double_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__double_(struct soap*, const char *URL, const xsd__double_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__double_(struct soap*, const char *URL, const xsd__double_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__double_(struct soap*, xsd__double_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__double_(struct soap*, const char *URL, xsd__double_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__double_(struct soap*, xsd__double_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__duration__"></a>

### `xsd__duration__`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 266, is a simple content wrapper *`xsd:duration`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__duration__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:duration' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__duration__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__duration__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__duration__, default initialized and not managed by a soap context
        virtual xsd__duration__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__duration__); }
      public:
        /// Constructor with default initializations
        xsd__duration__() : __item() { }
        virtual ~xsd__duration__() { }
        /// Friend allocator used by soap_new_xsd__duration__(struct soap*, int)
        friend SOAP_FMAC1 xsd__duration__ * SOAP_FMAC2 soap_instantiate_xsd__duration__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `char *__item` is simple content of XML schema type *`xsd:duration`* wrapped in *`xsd:duration`*, where the type of this member is <code><a href="#xsd__duration"> xsd__duration </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__duration__` are available:

- `xsd__duration__ *soap_new_xsd__duration__(struct soap*)` managed allocation with default initialization
- `xsd__duration__ *soap_new_xsd__duration__(struct soap*, int n)` managed allocation of array `xsd__duration__[n]`
- `xsd__duration__ *soap_new_req_xsd__duration__(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__duration__ *soap_new_set_xsd__duration__(struct soap*, char *__item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__duration__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__duration__(struct soap*, const xsd__duration__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__duration__(struct soap*, const char *URL, const xsd__duration__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__duration__(struct soap*, const char *URL, const xsd__duration__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__duration__(struct soap*, const char *URL, const xsd__duration__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__duration__(struct soap*, xsd__duration__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__duration__(struct soap*, const char *URL, xsd__duration__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__duration__(struct soap*, xsd__duration__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__float_"></a>

### `xsd__float_`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 273, is a simple content wrapper *`xsd:float`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__float_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:float' wrapped by this struct
        float __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__float_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__float_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__float_, default initialized and not managed by a soap context
        virtual xsd__float_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__float_); }
      public:
        /// Constructor with default initializations
        xsd__float_() : __item() { }
        virtual ~xsd__float_() { }
        /// Friend allocator used by soap_new_xsd__float_(struct soap*, int)
        friend SOAP_FMAC1 xsd__float_ * SOAP_FMAC2 soap_instantiate_xsd__float_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `float __item` is simple content of XML schema type *`xsd:float`* wrapped in *`xsd:float`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__float_` are available:

- `xsd__float_ *soap_new_xsd__float_(struct soap*)` managed allocation with default initialization
- `xsd__float_ *soap_new_xsd__float_(struct soap*, int n)` managed allocation of array `xsd__float_[n]`
- `xsd__float_ *soap_new_req_xsd__float_(struct soap*, float __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__float_ *soap_new_set_xsd__float_(struct soap*, float __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__float_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__float_(struct soap*, const xsd__float_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__float_(struct soap*, const char *URL, const xsd__float_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__float_(struct soap*, const char *URL, const xsd__float_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__float_(struct soap*, const char *URL, const xsd__float_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__float_(struct soap*, xsd__float_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__float_(struct soap*, const char *URL, xsd__float_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__float_(struct soap*, xsd__float_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__int_"></a>

### `xsd__int_`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 280, is a simple content wrapper *`xsd:int`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__int_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:int' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__int_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__int_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__int_, default initialized and not managed by a soap context
        virtual xsd__int_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__int_); }
      public:
        /// Constructor with default initializations
        xsd__int_() : __item() { }
        virtual ~xsd__int_() { }
        /// Friend allocator used by soap_new_xsd__int_(struct soap*, int)
        friend SOAP_FMAC1 xsd__int_ * SOAP_FMAC2 soap_instantiate_xsd__int_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `int __item` is simple content of XML schema type *`xsd:int`* wrapped in *`xsd:int`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__int_` are available:

- `xsd__int_ *soap_new_xsd__int_(struct soap*)` managed allocation with default initialization
- `xsd__int_ *soap_new_xsd__int_(struct soap*, int n)` managed allocation of array `xsd__int_[n]`
- `xsd__int_ *soap_new_req_xsd__int_(struct soap*, int __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__int_ *soap_new_set_xsd__int_(struct soap*, int __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__int_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__int_(struct soap*, const xsd__int_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__int_(struct soap*, const char *URL, const xsd__int_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__int_(struct soap*, const char *URL, const xsd__int_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__int_(struct soap*, const char *URL, const xsd__int_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__int_(struct soap*, xsd__int_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__int_(struct soap*, const char *URL, xsd__int_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__int_(struct soap*, xsd__int_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__long_"></a>

### `xsd__long_`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 287, is a simple content wrapper *`xsd:long`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__long_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:long' wrapped by this struct
        LONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__long_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__long_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__long_, default initialized and not managed by a soap context
        virtual xsd__long_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__long_); }
      public:
        /// Constructor with default initializations
        xsd__long_() : __item() { }
        virtual ~xsd__long_() { }
        /// Friend allocator used by soap_new_xsd__long_(struct soap*, int)
        friend SOAP_FMAC1 xsd__long_ * SOAP_FMAC2 soap_instantiate_xsd__long_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `LONG64 __item` is simple content of XML schema type *`xsd:long`* wrapped in *`xsd:long`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__long_` are available:

- `xsd__long_ *soap_new_xsd__long_(struct soap*)` managed allocation with default initialization
- `xsd__long_ *soap_new_xsd__long_(struct soap*, int n)` managed allocation of array `xsd__long_[n]`
- `xsd__long_ *soap_new_req_xsd__long_(struct soap*, LONG64 __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__long_ *soap_new_set_xsd__long_(struct soap*, LONG64 __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__long_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__long_(struct soap*, const xsd__long_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__long_(struct soap*, const char *URL, const xsd__long_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__long_(struct soap*, const char *URL, const xsd__long_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__long_(struct soap*, const char *URL, const xsd__long_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__long_(struct soap*, xsd__long_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__long_(struct soap*, const char *URL, xsd__long_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__long_(struct soap*, xsd__long_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__short_"></a>

### `xsd__short_`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 294, is a simple content wrapper *`xsd:short`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__short_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:short' wrapped by this struct
        short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__short_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__short_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__short_, default initialized and not managed by a soap context
        virtual xsd__short_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__short_); }
      public:
        /// Constructor with default initializations
        xsd__short_() : __item() { }
        virtual ~xsd__short_() { }
        /// Friend allocator used by soap_new_xsd__short_(struct soap*, int)
        friend SOAP_FMAC1 xsd__short_ * SOAP_FMAC2 soap_instantiate_xsd__short_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `short __item` is simple content of XML schema type *`xsd:short`* wrapped in *`xsd:short`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__short_` are available:

- `xsd__short_ *soap_new_xsd__short_(struct soap*)` managed allocation with default initialization
- `xsd__short_ *soap_new_xsd__short_(struct soap*, int n)` managed allocation of array `xsd__short_[n]`
- `xsd__short_ *soap_new_req_xsd__short_(struct soap*, short __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__short_ *soap_new_set_xsd__short_(struct soap*, short __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__short_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__short_(struct soap*, const xsd__short_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__short_(struct soap*, const char *URL, const xsd__short_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__short_(struct soap*, const char *URL, const xsd__short_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__short_(struct soap*, const char *URL, const xsd__short_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__short_(struct soap*, xsd__short_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__short_(struct soap*, const char *URL, xsd__short_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__short_(struct soap*, xsd__short_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__string_"></a>

### `xsd__string_`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 301, is a simple content wrapper *`xsd:string`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__string_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:string' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__string_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__string_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__string_, default initialized and not managed by a soap context
        virtual xsd__string_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__string_); }
      public:
        /// Constructor with default initializations
        xsd__string_() : __item() { }
        virtual ~xsd__string_() { }
        /// Friend allocator used by soap_new_xsd__string_(struct soap*, int)
        friend SOAP_FMAC1 xsd__string_ * SOAP_FMAC2 soap_instantiate_xsd__string_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `char *__item` is simple content of XML schema type *`xsd:string`* wrapped in *`xsd:string`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__string_` are available:

- `xsd__string_ *soap_new_xsd__string_(struct soap*)` managed allocation with default initialization
- `xsd__string_ *soap_new_xsd__string_(struct soap*, int n)` managed allocation of array `xsd__string_[n]`
- `xsd__string_ *soap_new_req_xsd__string_(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__string_ *soap_new_set_xsd__string_(struct soap*, char *__item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__string_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__string_(struct soap*, const xsd__string_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__string_(struct soap*, const char *URL, const xsd__string_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__string_(struct soap*, const char *URL, const xsd__string_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__string_(struct soap*, const char *URL, const xsd__string_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__string_(struct soap*, xsd__string_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__string_(struct soap*, const char *URL, xsd__string_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__string_(struct soap*, xsd__string_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__unsignedByte__"></a>

### `xsd__unsignedByte__`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 308, is a simple content wrapper *`xsd:unsignedByte`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__unsignedByte__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:unsignedByte' wrapped by this struct
        unsigned char __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedByte__
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__unsignedByte__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedByte__, default initialized and not managed by a soap context
        virtual xsd__unsignedByte__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__unsignedByte__); }
      public:
        /// Constructor with default initializations
        xsd__unsignedByte__() : __item() { }
        virtual ~xsd__unsignedByte__() { }
        /// Friend allocator used by soap_new_xsd__unsignedByte__(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedByte__ * SOAP_FMAC2 soap_instantiate_xsd__unsignedByte__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `unsigned char __item` is simple content of XML schema type *`xsd:unsignedByte`* wrapped in *`xsd:unsignedByte`*, where the type of this member is <code><a href="#xsd__unsignedByte"> xsd__unsignedByte </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__unsignedByte__` are available:

- `xsd__unsignedByte__ *soap_new_xsd__unsignedByte__(struct soap*)` managed allocation with default initialization
- `xsd__unsignedByte__ *soap_new_xsd__unsignedByte__(struct soap*, int n)` managed allocation of array `xsd__unsignedByte__[n]`
- `xsd__unsignedByte__ *soap_new_req_xsd__unsignedByte__(struct soap*, unsigned char __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__unsignedByte__ *soap_new_set_xsd__unsignedByte__(struct soap*, unsigned char __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__unsignedByte__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__unsignedByte__(struct soap*, const xsd__unsignedByte__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__unsignedByte__(struct soap*, const char *URL, const xsd__unsignedByte__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__unsignedByte__(struct soap*, const char *URL, const xsd__unsignedByte__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__unsignedByte__(struct soap*, const char *URL, const xsd__unsignedByte__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__unsignedByte__(struct soap*, xsd__unsignedByte__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__unsignedByte__(struct soap*, const char *URL, xsd__unsignedByte__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__unsignedByte__(struct soap*, xsd__unsignedByte__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__unsignedInt_"></a>

### `xsd__unsignedInt_`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 315, is a simple content wrapper *`xsd:unsignedInt`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__unsignedInt_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:unsignedInt' wrapped by this struct
        unsigned int __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedInt_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__unsignedInt_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedInt_, default initialized and not managed by a soap context
        virtual xsd__unsignedInt_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__unsignedInt_); }
      public:
        /// Constructor with default initializations
        xsd__unsignedInt_() : __item() { }
        virtual ~xsd__unsignedInt_() { }
        /// Friend allocator used by soap_new_xsd__unsignedInt_(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedInt_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedInt_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `unsigned int __item` is simple content of XML schema type *`xsd:unsignedInt`* wrapped in *`xsd:unsignedInt`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__unsignedInt_` are available:

- `xsd__unsignedInt_ *soap_new_xsd__unsignedInt_(struct soap*)` managed allocation with default initialization
- `xsd__unsignedInt_ *soap_new_xsd__unsignedInt_(struct soap*, int n)` managed allocation of array `xsd__unsignedInt_[n]`
- `xsd__unsignedInt_ *soap_new_req_xsd__unsignedInt_(struct soap*, unsigned int __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__unsignedInt_ *soap_new_set_xsd__unsignedInt_(struct soap*, unsigned int __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__unsignedInt_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__unsignedInt_(struct soap*, const xsd__unsignedInt_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__unsignedInt_(struct soap*, const char *URL, const xsd__unsignedInt_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__unsignedInt_(struct soap*, const char *URL, const xsd__unsignedInt_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__unsignedInt_(struct soap*, const char *URL, const xsd__unsignedInt_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__unsignedInt_(struct soap*, xsd__unsignedInt_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__unsignedInt_(struct soap*, const char *URL, xsd__unsignedInt_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__unsignedInt_(struct soap*, xsd__unsignedInt_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__unsignedLong_"></a>

### `xsd__unsignedLong_`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 322, is a simple content wrapper *`xsd:unsignedLong`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__unsignedLong_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:unsignedLong' wrapped by this struct
        ULONG64 __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedLong_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__unsignedLong_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedLong_, default initialized and not managed by a soap context
        virtual xsd__unsignedLong_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__unsignedLong_); }
      public:
        /// Constructor with default initializations
        xsd__unsignedLong_() : __item() { }
        virtual ~xsd__unsignedLong_() { }
        /// Friend allocator used by soap_new_xsd__unsignedLong_(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedLong_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedLong_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `ULONG64 __item` is simple content of XML schema type *`xsd:unsignedLong`* wrapped in *`xsd:unsignedLong`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__unsignedLong_` are available:

- `xsd__unsignedLong_ *soap_new_xsd__unsignedLong_(struct soap*)` managed allocation with default initialization
- `xsd__unsignedLong_ *soap_new_xsd__unsignedLong_(struct soap*, int n)` managed allocation of array `xsd__unsignedLong_[n]`
- `xsd__unsignedLong_ *soap_new_req_xsd__unsignedLong_(struct soap*, ULONG64 __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__unsignedLong_ *soap_new_set_xsd__unsignedLong_(struct soap*, ULONG64 __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__unsignedLong_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__unsignedLong_(struct soap*, const xsd__unsignedLong_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__unsignedLong_(struct soap*, const char *URL, const xsd__unsignedLong_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__unsignedLong_(struct soap*, const char *URL, const xsd__unsignedLong_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__unsignedLong_(struct soap*, const char *URL, const xsd__unsignedLong_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__unsignedLong_(struct soap*, xsd__unsignedLong_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__unsignedLong_(struct soap*, const char *URL, xsd__unsignedLong_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__unsignedLong_(struct soap*, xsd__unsignedLong_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="xsd__unsignedShort_"></a>

### `xsd__unsignedShort_`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 329, is a simple content wrapper *`xsd:unsignedShort`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC xsd__unsignedShort_ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'xsd:unsignedShort' wrapped by this struct
        unsigned short __item;
      public:
        /// Return unique type id SOAP_TYPE_xsd__unsignedShort_
        virtual long soap_type(void) const { return SOAP_TYPE_xsd__unsignedShort_; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type xsd__unsignedShort_, default initialized and not managed by a soap context
        virtual xsd__unsignedShort_ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(xsd__unsignedShort_); }
      public:
        /// Constructor with default initializations
        xsd__unsignedShort_() : __item() { }
        virtual ~xsd__unsignedShort_() { }
        /// Friend allocator used by soap_new_xsd__unsignedShort_(struct soap*, int)
        friend SOAP_FMAC1 xsd__unsignedShort_ * SOAP_FMAC2 soap_instantiate_xsd__unsignedShort_(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `unsigned short __item` is simple content of XML schema type *`xsd:unsignedShort`* wrapped in *`xsd:unsignedShort`* (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `xsd__unsignedShort_` are available:

- `xsd__unsignedShort_ *soap_new_xsd__unsignedShort_(struct soap*)` managed allocation with default initialization
- `xsd__unsignedShort_ *soap_new_xsd__unsignedShort_(struct soap*, int n)` managed allocation of array `xsd__unsignedShort_[n]`
- `xsd__unsignedShort_ *soap_new_req_xsd__unsignedShort_(struct soap*, unsigned short __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `xsd__unsignedShort_ *soap_new_set_xsd__unsignedShort_(struct soap*, unsigned short __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void xsd__unsignedShort_::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_xsd__unsignedShort_(struct soap*, const xsd__unsignedShort_*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_xsd__unsignedShort_(struct soap*, const char *URL, const xsd__unsignedShort_*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_xsd__unsignedShort_(struct soap*, const char *URL, const xsd__unsignedShort_*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_xsd__unsignedShort_(struct soap*, const char *URL, const xsd__unsignedShort_*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_xsd__unsignedShort_(struct soap*, xsd__unsignedShort_*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_xsd__unsignedShort_(struct soap*, const char *URL, xsd__unsignedShort_*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_xsd__unsignedShort_(struct soap*, xsd__unsignedShort_*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__char__"></a>

### `ns2__char__`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 419, is a simple content wrapper *`ns2:char`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__char__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ns2:char' wrapped by this struct
        int __item;
      public:
        /// Return unique type id SOAP_TYPE_ns2__char__
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__char__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__char__, default initialized and not managed by a soap context
        virtual ns2__char__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__char__); }
      public:
        /// Constructor with default initializations
        ns2__char__() : __item() { }
        virtual ~ns2__char__() { }
        /// Friend allocator used by soap_new_ns2__char__(struct soap*, int)
        friend SOAP_FMAC1 ns2__char__ * SOAP_FMAC2 soap_instantiate_ns2__char__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `int __item` is simple content of XML schema type *`ns2:char`* wrapped in *`ns2:char`*, where the type of this member is <code><a href="#ns2__char"> ns2__char </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `ns2__char__` are available:

- `ns2__char__ *soap_new_ns2__char__(struct soap*)` managed allocation with default initialization
- `ns2__char__ *soap_new_ns2__char__(struct soap*, int n)` managed allocation of array `ns2__char__[n]`
- `ns2__char__ *soap_new_req_ns2__char__(struct soap*, int __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__char__ *soap_new_set_ns2__char__(struct soap*, int __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns2__char__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__char__(struct soap*, const ns2__char__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__char__(struct soap*, const char *URL, const ns2__char__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__char__(struct soap*, const char *URL, const ns2__char__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__char__(struct soap*, const char *URL, const ns2__char__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__char__(struct soap*, ns2__char__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__char__(struct soap*, const char *URL, ns2__char__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__char__(struct soap*, ns2__char__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__duration__"></a>

### `ns2__duration__`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 433, is a simple content wrapper *`ns2:duration`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__duration__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ns2:duration' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_ns2__duration__
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__duration__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__duration__, default initialized and not managed by a soap context
        virtual ns2__duration__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__duration__); }
      public:
        /// Constructor with default initializations
        ns2__duration__() : __item() { }
        virtual ~ns2__duration__() { }
        /// Friend allocator used by soap_new_ns2__duration__(struct soap*, int)
        friend SOAP_FMAC1 ns2__duration__ * SOAP_FMAC2 soap_instantiate_ns2__duration__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `char *__item` is simple content of XML schema type *`ns2:duration`* wrapped in *`ns2:duration`*, where the type of this member is <code><a href="#xsd__duration"> xsd__duration </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `ns2__duration__` are available:

- `ns2__duration__ *soap_new_ns2__duration__(struct soap*)` managed allocation with default initialization
- `ns2__duration__ *soap_new_ns2__duration__(struct soap*, int n)` managed allocation of array `ns2__duration__[n]`
- `ns2__duration__ *soap_new_req_ns2__duration__(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__duration__ *soap_new_set_ns2__duration__(struct soap*, char *__item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns2__duration__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__duration__(struct soap*, const ns2__duration__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__duration__(struct soap*, const char *URL, const ns2__duration__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__duration__(struct soap*, const char *URL, const ns2__duration__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__duration__(struct soap*, const char *URL, const ns2__duration__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__duration__(struct soap*, ns2__duration__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__duration__(struct soap*, const char *URL, ns2__duration__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__duration__(struct soap*, ns2__duration__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns2__guid__"></a>

### `ns2__guid__`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 446, is a simple content wrapper *`ns2:guid`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns2__guid__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ns2:guid' wrapped by this struct
        char *__item;
      public:
        /// Return unique type id SOAP_TYPE_ns2__guid__
        virtual long soap_type(void) const { return SOAP_TYPE_ns2__guid__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__guid__, default initialized and not managed by a soap context
        virtual ns2__guid__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns2__guid__); }
      public:
        /// Constructor with default initializations
        ns2__guid__() : __item() { }
        virtual ~ns2__guid__() { }
        /// Friend allocator used by soap_new_ns2__guid__(struct soap*, int)
        friend SOAP_FMAC1 ns2__guid__ * SOAP_FMAC2 soap_instantiate_ns2__guid__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `char *__item` is simple content of XML schema type *`ns2:guid`* wrapped in *`ns2:guid`*, where the type of this member is <code><a href="#ns2__guid"> ns2__guid </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `ns2__guid__` are available:

- `ns2__guid__ *soap_new_ns2__guid__(struct soap*)` managed allocation with default initialization
- `ns2__guid__ *soap_new_ns2__guid__(struct soap*, int n)` managed allocation of array `ns2__guid__[n]`
- `ns2__guid__ *soap_new_req_ns2__guid__(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns2__guid__ *soap_new_set_ns2__guid__(struct soap*, char *__item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns2__guid__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns2__guid__(struct soap*, const ns2__guid__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns2__guid__(struct soap*, const char *URL, const ns2__guid__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns2__guid__(struct soap*, const char *URL, const ns2__guid__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns2__guid__(struct soap*, const char *URL, const ns2__guid__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns2__guid__(struct soap*, ns2__guid__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns2__guid__(struct soap*, const char *URL, ns2__guid__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns2__guid__(struct soap*, ns2__guid__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns5__StreamBody__"></a>

### `ns5__StreamBody__`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 482, is a simple content wrapper *`ns5:StreamBody`*, meaning it wraps a primitive type, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns5__StreamBody__ : public xsd__anyType {
      public:
        /// Simple content of XML schema type 'ns5:StreamBody' wrapped by this struct
        xsd__base64Binary __item;
      public:
        /// Return unique type id SOAP_TYPE_ns5__StreamBody__
        virtual long soap_type(void) const { return SOAP_TYPE_ns5__StreamBody__; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns5__StreamBody__, default initialized and not managed by a soap context
        virtual ns5__StreamBody__ *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns5__StreamBody__); }
      public:
        /// Constructor with default initializations
        ns5__StreamBody__() : __item() { }
        virtual ~ns5__StreamBody__() { }
        /// Friend allocator used by soap_new_ns5__StreamBody__(struct soap*, int)
        friend SOAP_FMAC1 ns5__StreamBody__ * SOAP_FMAC2 soap_instantiate_ns5__StreamBody__(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `xsd__base64Binary __item` is simple content of XML schema type *`ns5:StreamBody`* wrapped in *`ns5:StreamBody`*, where the type of this member is <code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code> (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `ns5__StreamBody__` are available:

- `ns5__StreamBody__ *soap_new_ns5__StreamBody__(struct soap*)` managed allocation with default initialization
- `ns5__StreamBody__ *soap_new_ns5__StreamBody__(struct soap*, int n)` managed allocation of array `ns5__StreamBody__[n]`
- `ns5__StreamBody__ *soap_new_req_ns5__StreamBody__(struct soap*, const xsd__base64Binary& __item)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns5__StreamBody__ *soap_new_set_ns5__StreamBody__(struct soap*, const xsd__base64Binary& __item, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns5__StreamBody__::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns5__StreamBody__(struct soap*, const ns5__StreamBody__*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns5__StreamBody__(struct soap*, const char *URL, const ns5__StreamBody__*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns5__StreamBody__(struct soap*, const char *URL, const ns5__StreamBody__*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns5__StreamBody__(struct soap*, const char *URL, const ns5__StreamBody__*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns5__StreamBody__(struct soap*, ns5__StreamBody__*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns5__StreamBody__(struct soap*, const char *URL, ns5__StreamBody__*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns5__StreamBody__(struct soap*, ns5__StreamBody__*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns1__Sign"></a>

### `_ns1__Sign`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 342, is serialized as XML schema type *`ns1:Sign`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns1__Sign {
      public:
        /// Optional element 'ns1:data' of XML schema type 'ns3:ReceiptRequest'
        ns3__ReceiptRequest *data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Sign
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Sign; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Sign, default initialized and not managed by a soap context
        virtual _ns1__Sign *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Sign); }
      public:
        /// Constructor with default initializations
        _ns1__Sign() : data(), soap() { }
        virtual ~_ns1__Sign() { }
        /// Friend allocator used by soap_new__ns1__Sign(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Sign * SOAP_FMAC2 soap_instantiate__ns1__Sign(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns3__ReceiptRequest *data` is an optional element *`<ns1:data>`* of XML schema type *`ns3:ReceiptRequest`*, where the type of this member is a pointer to <code><a href="#ns3__ReceiptRequest"> ns3__ReceiptRequest </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns1__Sign` are available:

- `_ns1__Sign *soap_new__ns1__Sign(struct soap*)` managed allocation with default initialization
- `_ns1__Sign *soap_new__ns1__Sign(struct soap*, int n)` managed allocation of array `_ns1__Sign[n]`
- `_ns1__Sign *soap_new_req__ns1__Sign(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns1__Sign *soap_new_set__ns1__Sign(struct soap*, ns3__ReceiptRequest *data)` managed allocation with public members assigned the values of these parameters
- `void _ns1__Sign::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns1__Sign(struct soap*, const _ns1__Sign*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns1__Sign(struct soap*, const char *URL, const _ns1__Sign*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns1__Sign(struct soap*, const char *URL, const _ns1__Sign*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns1__Sign(struct soap*, const char *URL, const _ns1__Sign*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns1__Sign(struct soap*, _ns1__Sign*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns1__Sign(struct soap*, const char *URL, _ns1__Sign*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns1__Sign(struct soap*, _ns1__Sign*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns1__SignResponse"></a>

### `_ns1__SignResponse`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 344, is serialized as XML schema type *`ns1:SignResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns1__SignResponse {
      public:
        /// Optional element 'ns1:SignResult' of XML schema type 'ns3:ReceiptResponse'
        ns3__ReceiptResponse *SignResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__SignResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__SignResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__SignResponse, default initialized and not managed by a soap context
        virtual _ns1__SignResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__SignResponse); }
      public:
        /// Constructor with default initializations
        _ns1__SignResponse() : SignResult(), soap() { }
        virtual ~_ns1__SignResponse() { }
        /// Friend allocator used by soap_new__ns1__SignResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__SignResponse * SOAP_FMAC2 soap_instantiate__ns1__SignResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `ns3__ReceiptResponse *SignResult` is an optional element *`<ns1:SignResult>`* of XML schema type *`ns3:ReceiptResponse`*, where the type of this member is a pointer to <code><a href="#ns3__ReceiptResponse"> ns3__ReceiptResponse </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns1__SignResponse` are available:

- `_ns1__SignResponse *soap_new__ns1__SignResponse(struct soap*)` managed allocation with default initialization
- `_ns1__SignResponse *soap_new__ns1__SignResponse(struct soap*, int n)` managed allocation of array `_ns1__SignResponse[n]`
- `_ns1__SignResponse *soap_new_req__ns1__SignResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns1__SignResponse *soap_new_set__ns1__SignResponse(struct soap*, ns3__ReceiptResponse *SignResult)` managed allocation with public members assigned the values of these parameters
- `void _ns1__SignResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns1__SignResponse(struct soap*, const _ns1__SignResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns1__SignResponse(struct soap*, const char *URL, const _ns1__SignResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns1__SignResponse(struct soap*, const char *URL, const _ns1__SignResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns1__SignResponse(struct soap*, const char *URL, const _ns1__SignResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns1__SignResponse(struct soap*, _ns1__SignResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns1__SignResponse(struct soap*, const char *URL, _ns1__SignResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns1__SignResponse(struct soap*, _ns1__SignResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns1__Journal"></a>

### `_ns1__Journal`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 346, is serialized as XML schema type *`ns1:Journal`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns1__Journal {
      public:
        /// Optional element 'ns1:ftJournalType' of XML schema type 'xsd:long'
        LONG64 *ftJournalType;
        /// Optional element 'ns1:from' of XML schema type 'xsd:long'
        LONG64 *from;
        /// Optional element 'ns1:to' of XML schema type 'xsd:long'
        LONG64 *to;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Journal
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Journal; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Journal, default initialized and not managed by a soap context
        virtual _ns1__Journal *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Journal); }
      public:
        /// Constructor with default initializations
        _ns1__Journal() : ftJournalType(), from(), to(), soap() { }
        virtual ~_ns1__Journal() { }
        /// Friend allocator used by soap_new__ns1__Journal(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Journal * SOAP_FMAC2 soap_instantiate__ns1__Journal(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `LONG64 *ftJournalType` is an optional element *`<ns1:ftJournalType>`* of XML schema type *`xsd:long`*
- `LONG64 *from` is an optional element *`<ns1:from>`* of XML schema type *`xsd:long`*
- `LONG64 *to` is an optional element *`<ns1:to>`* of XML schema type *`xsd:long`*
- `struct soap *soap` the context that manages this object

The following operations on `_ns1__Journal` are available:

- `_ns1__Journal *soap_new__ns1__Journal(struct soap*)` managed allocation with default initialization
- `_ns1__Journal *soap_new__ns1__Journal(struct soap*, int n)` managed allocation of array `_ns1__Journal[n]`
- `_ns1__Journal *soap_new_req__ns1__Journal(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns1__Journal *soap_new_set__ns1__Journal(struct soap*, LONG64 *ftJournalType, LONG64 *from, LONG64 *to)` managed allocation with public members assigned the values of these parameters
- `void _ns1__Journal::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns1__Journal(struct soap*, const _ns1__Journal*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns1__Journal(struct soap*, const char *URL, const _ns1__Journal*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns1__Journal(struct soap*, const char *URL, const _ns1__Journal*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns1__Journal(struct soap*, const char *URL, const _ns1__Journal*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns1__Journal(struct soap*, _ns1__Journal*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns1__Journal(struct soap*, const char *URL, _ns1__Journal*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns1__Journal(struct soap*, _ns1__Journal*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns1__JournalResponse"></a>

### `_ns1__JournalResponse`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 348, is serialized as XML schema type *`ns1:JournalResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns1__JournalResponse {
      public:
        /// Required element 'ns1:JournalResult' of XML schema type 'ns5:StreamBody'
        xsd__base64Binary JournalResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__JournalResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__JournalResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__JournalResponse, default initialized and not managed by a soap context
        virtual _ns1__JournalResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__JournalResponse); }
      public:
        /// Constructor with default initializations
        _ns1__JournalResponse() : JournalResult(), soap() { }
        virtual ~_ns1__JournalResponse() { }
        /// Friend allocator used by soap_new__ns1__JournalResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__JournalResponse * SOAP_FMAC2 soap_instantiate__ns1__JournalResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `xsd__base64Binary JournalResult` is a required element *`<ns1:JournalResult>`* of XML schema type *`ns5:StreamBody`*, where the type of this member is <code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code>
- `struct soap *soap` the context that manages this object

The following operations on `_ns1__JournalResponse` are available:

- `_ns1__JournalResponse *soap_new__ns1__JournalResponse(struct soap*)` managed allocation with default initialization
- `_ns1__JournalResponse *soap_new__ns1__JournalResponse(struct soap*, int n)` managed allocation of array `_ns1__JournalResponse[n]`
- `_ns1__JournalResponse *soap_new_req__ns1__JournalResponse(struct soap*, const xsd__base64Binary& JournalResult)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns1__JournalResponse *soap_new_set__ns1__JournalResponse(struct soap*, const xsd__base64Binary& JournalResult)` managed allocation with public members assigned the values of these parameters
- `void _ns1__JournalResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns1__JournalResponse(struct soap*, const _ns1__JournalResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns1__JournalResponse(struct soap*, const char *URL, const _ns1__JournalResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns1__JournalResponse(struct soap*, const char *URL, const _ns1__JournalResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns1__JournalResponse(struct soap*, const char *URL, const _ns1__JournalResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns1__JournalResponse(struct soap*, _ns1__JournalResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns1__JournalResponse(struct soap*, const char *URL, _ns1__JournalResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns1__JournalResponse(struct soap*, _ns1__JournalResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns1__Echo"></a>

### `_ns1__Echo`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 350, is serialized as XML schema type *`ns1:Echo`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns1__Echo {
      public:
        /// Optional element 'ns1:message' of XML schema type 'xsd:string'
        char *message;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Echo
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Echo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Echo, default initialized and not managed by a soap context
        virtual _ns1__Echo *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Echo); }
      public:
        /// Constructor with default initializations
        _ns1__Echo() : message(), soap() { }
        virtual ~_ns1__Echo() { }
        /// Friend allocator used by soap_new__ns1__Echo(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Echo * SOAP_FMAC2 soap_instantiate__ns1__Echo(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *message` is an optional element *`<ns1:message>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `_ns1__Echo` are available:

- `_ns1__Echo *soap_new__ns1__Echo(struct soap*)` managed allocation with default initialization
- `_ns1__Echo *soap_new__ns1__Echo(struct soap*, int n)` managed allocation of array `_ns1__Echo[n]`
- `_ns1__Echo *soap_new_req__ns1__Echo(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns1__Echo *soap_new_set__ns1__Echo(struct soap*, char *message)` managed allocation with public members assigned the values of these parameters
- `void _ns1__Echo::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns1__Echo(struct soap*, const _ns1__Echo*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns1__Echo(struct soap*, const char *URL, const _ns1__Echo*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns1__Echo(struct soap*, const char *URL, const _ns1__Echo*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns1__Echo(struct soap*, const char *URL, const _ns1__Echo*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns1__Echo(struct soap*, _ns1__Echo*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns1__Echo(struct soap*, const char *URL, _ns1__Echo*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns1__Echo(struct soap*, _ns1__Echo*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="_ns1__EchoResponse"></a>

### `_ns1__EchoResponse`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 352, is serialized as XML schema type *`ns1:EchoResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC _ns1__EchoResponse {
      public:
        /// Optional element 'ns1:EchoResult' of XML schema type 'xsd:string'
        char *EchoResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__EchoResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__EchoResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__EchoResponse, default initialized and not managed by a soap context
        virtual _ns1__EchoResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__EchoResponse); }
      public:
        /// Constructor with default initializations
        _ns1__EchoResponse() : EchoResult(), soap() { }
        virtual ~_ns1__EchoResponse() { }
        /// Friend allocator used by soap_new__ns1__EchoResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__EchoResponse * SOAP_FMAC2 soap_instantiate__ns1__EchoResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- `char *EchoResult` is an optional element *`<ns1:EchoResult>`* of XML schema type *`xsd:string`*
- `struct soap *soap` the context that manages this object

The following operations on `_ns1__EchoResponse` are available:

- `_ns1__EchoResponse *soap_new__ns1__EchoResponse(struct soap*)` managed allocation with default initialization
- `_ns1__EchoResponse *soap_new__ns1__EchoResponse(struct soap*, int n)` managed allocation of array `_ns1__EchoResponse[n]`
- `_ns1__EchoResponse *soap_new_req__ns1__EchoResponse(struct soap*)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `_ns1__EchoResponse *soap_new_set__ns1__EchoResponse(struct soap*, char *EchoResult)` managed allocation with public members assigned the values of these parameters
- `void _ns1__EchoResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write__ns1__EchoResponse(struct soap*, const _ns1__EchoResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT__ns1__EchoResponse(struct soap*, const char *URL, const _ns1__EchoResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH__ns1__EchoResponse(struct soap*, const char *URL, const _ns1__EchoResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send__ns1__EchoResponse(struct soap*, const char *URL, const _ns1__EchoResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read__ns1__EchoResponse(struct soap*, _ns1__EchoResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET__ns1__EchoResponse(struct soap*, const char *URL, _ns1__EchoResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv__ns1__EchoResponse(struct soap*, _ns1__EchoResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns3__ReceiptRequest"></a>

### `ns3__ReceiptRequest`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 354, is serialized as XML schema type *`ns3:ReceiptRequest`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns3__ReceiptRequest : public xsd__anyType {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns3:ftCashBoxID' of XML schema type 'xsd:string'
        char *ftCashBoxID;
        /// Optional element 'ns3:ftQueueID' of XML schema type 'xsd:string'
        char *ftQueueID;
        /// Optional element 'ns3:ftPosSystemId' of XML schema type 'xsd:string'
        char *ftPosSystemId;
        /// Required nillable (xsi:nil when NULL) element 'ns3:cbTerminalID' of XML schema type 'xsd:string'
        char *cbTerminalID;
        /// Required nillable (xsi:nil when NULL) element 'ns3:cbReceiptReference' of XML schema type 'xsd:string'
        char *cbReceiptReference;
        /// Required element 'ns3:cbReceiptMoment' of XML schema type 'xsd:dateTime'
        time_t cbReceiptMoment;
        /// Required nillable (xsi:nil when NULL) element 'ns3:cbChargeItems' of XML schema type 'ns3:ArrayOfChargeItem'
        ns3__ArrayOfChargeItem *cbChargeItems;
        /// Required nillable (xsi:nil when NULL) element 'ns3:cbPayItems' of XML schema type 'ns3:ArrayOfPayItem'
        ns3__ArrayOfPayItem *cbPayItems;
        /// Required element 'ns3:ftReceiptCase' of XML schema type 'xsd:long'
        LONG64 ftReceiptCase;
        /// Optional element 'ns3:ftReceiptCaseData' of XML schema type 'xsd:string'
        char *ftReceiptCaseData;
        /// Optional element 'ns3:cbReceiptAmount' of XML schema type 'xsd:decimal'
        char *cbReceiptAmount;
        /// Optional element 'ns3:cbUser' of XML schema type 'xsd:string'
        char *cbUser;
        /// Optional element 'ns3:cbArea' of XML schema type 'xsd:string'
        char *cbArea;
        /// Optional element 'ns3:cbCustomer' of XML schema type 'xsd:string'
        char *cbCustomer;
        /// Optional element 'ns3:cbSettlement' of XML schema type 'xsd:string'
        char *cbSettlement;
        /// Optional element 'ns3:cbPreviousReceiptReference' of XML schema type 'xsd:string'
        char *cbPreviousReceiptReference;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ReceiptRequest
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__ReceiptRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ReceiptRequest, default initialized and not managed by a soap context
        virtual ns3__ReceiptRequest *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__ReceiptRequest); }
      public:
        /// Constructor with default initializations
        ns3__ReceiptRequest() : ftCashBoxID(), ftQueueID(), ftPosSystemId(), cbTerminalID(), cbReceiptReference(), cbReceiptMoment(), cbChargeItems(), cbPayItems(), ftReceiptCase(), ftReceiptCaseData(), cbReceiptAmount(), cbUser(), cbArea(), cbCustomer(), cbSettlement(), cbPreviousReceiptReference() { }
        virtual ~ns3__ReceiptRequest() { }
        /// Friend allocator used by soap_new_ns3__ReceiptRequest(struct soap*, int)
        friend SOAP_FMAC1 ns3__ReceiptRequest * SOAP_FMAC2 soap_instantiate_ns3__ReceiptRequest(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `char *ftCashBoxID` is a required nillable (xsi:nil when NULL) element *`<ns3:ftCashBoxID>`* of XML schema type *`xsd:string`*
- `char *ftQueueID` is an optional element *`<ns3:ftQueueID>`* of XML schema type *`xsd:string`*
- `char *ftPosSystemId` is an optional element *`<ns3:ftPosSystemId>`* of XML schema type *`xsd:string`*
- `char *cbTerminalID` is a required nillable (xsi:nil when NULL) element *`<ns3:cbTerminalID>`* of XML schema type *`xsd:string`*
- `char *cbReceiptReference` is a required nillable (xsi:nil when NULL) element *`<ns3:cbReceiptReference>`* of XML schema type *`xsd:string`*
- `time_t cbReceiptMoment` is a required element *`<ns3:cbReceiptMoment>`* of XML schema type *`xsd:dateTime`*
- `ns3__ArrayOfChargeItem *cbChargeItems` is a required nillable (xsi:nil when NULL) element *`<ns3:cbChargeItems>`* of XML schema type *`ns3:ArrayOfChargeItem`*, where the type of this member is a pointer to <code><a href="#ns3__ArrayOfChargeItem"> ns3__ArrayOfChargeItem </a></code>
- `ns3__ArrayOfPayItem *cbPayItems` is a required nillable (xsi:nil when NULL) element *`<ns3:cbPayItems>`* of XML schema type *`ns3:ArrayOfPayItem`*, where the type of this member is a pointer to <code><a href="#ns3__ArrayOfPayItem"> ns3__ArrayOfPayItem </a></code>
- `LONG64 ftReceiptCase` is a required element *`<ns3:ftReceiptCase>`* of XML schema type *`xsd:long`*
- `char *ftReceiptCaseData` is an optional element *`<ns3:ftReceiptCaseData>`* of XML schema type *`xsd:string`*
- `char *cbReceiptAmount` is an optional element *`<ns3:cbReceiptAmount>`* of XML schema type *`xsd:decimal`*, where the type of this member is <code><a href="#xsd__decimal"> xsd__decimal </a></code>
- `char *cbUser` is an optional element *`<ns3:cbUser>`* of XML schema type *`xsd:string`*
- `char *cbArea` is an optional element *`<ns3:cbArea>`* of XML schema type *`xsd:string`*
- `char *cbCustomer` is an optional element *`<ns3:cbCustomer>`* of XML schema type *`xsd:string`*
- `char *cbSettlement` is an optional element *`<ns3:cbSettlement>`* of XML schema type *`xsd:string`*
- `char *cbPreviousReceiptReference` is an optional element *`<ns3:cbPreviousReceiptReference>`* of XML schema type *`xsd:string`*

The following operations on `ns3__ReceiptRequest` are available:

- `ns3__ReceiptRequest *soap_new_ns3__ReceiptRequest(struct soap*)` managed allocation with default initialization
- `ns3__ReceiptRequest *soap_new_ns3__ReceiptRequest(struct soap*, int n)` managed allocation of array `ns3__ReceiptRequest[n]`
- `ns3__ReceiptRequest *soap_new_req_ns3__ReceiptRequest(struct soap*, char *ftCashBoxID, char *cbTerminalID, char *cbReceiptReference, time_t cbReceiptMoment, ns3__ArrayOfChargeItem *cbChargeItems, ns3__ArrayOfPayItem *cbPayItems, LONG64 ftReceiptCase)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns3__ReceiptRequest *soap_new_set_ns3__ReceiptRequest(struct soap*, char *ftCashBoxID, char *ftQueueID, char *ftPosSystemId, char *cbTerminalID, char *cbReceiptReference, time_t cbReceiptMoment, ns3__ArrayOfChargeItem *cbChargeItems, ns3__ArrayOfPayItem *cbPayItems, LONG64 ftReceiptCase, char *ftReceiptCaseData, char *cbReceiptAmount, char *cbUser, char *cbArea, char *cbCustomer, char *cbSettlement, char *cbPreviousReceiptReference, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns3__ReceiptRequest::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns3__ReceiptRequest(struct soap*, const ns3__ReceiptRequest*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns3__ReceiptRequest(struct soap*, const char *URL, const ns3__ReceiptRequest*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns3__ReceiptRequest(struct soap*, const char *URL, const ns3__ReceiptRequest*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns3__ReceiptRequest(struct soap*, const char *URL, const ns3__ReceiptRequest*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns3__ReceiptRequest(struct soap*, ns3__ReceiptRequest*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns3__ReceiptRequest(struct soap*, const char *URL, ns3__ReceiptRequest*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns3__ReceiptRequest(struct soap*, ns3__ReceiptRequest*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns3__ArrayOfChargeItem"></a>

### `ns3__ArrayOfChargeItem`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 356, is serialized as XML schema type *`ns3:ArrayOfChargeItem`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns3__ArrayOfChargeItem : public xsd__anyType {
      public:
        /// Sequence of elements 'ns3:ChargeItem' of XML schema type 'ns3:ChargeItem' stored in dynamic array ChargeItem of length __sizeChargeItem
        int __sizeChargeItem;
        ns3__ChargeItem **ChargeItem;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ArrayOfChargeItem
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__ArrayOfChargeItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ArrayOfChargeItem, default initialized and not managed by a soap context
        virtual ns3__ArrayOfChargeItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__ArrayOfChargeItem); }
      public:
        /// Constructor with default initializations
        ns3__ArrayOfChargeItem() : __sizeChargeItem(), ChargeItem() { }
        virtual ~ns3__ArrayOfChargeItem() { }
        /// Friend allocator used by soap_new_ns3__ArrayOfChargeItem(struct soap*, int)
        friend SOAP_FMAC1 ns3__ArrayOfChargeItem * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfChargeItem(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `int __sizeChargeItem` is a sequence of elements *`<ns3:ChargeItem>`* of XML schema type *`ns3:ChargeItem`* stored in dynamic array `ChargeItem` of length `__sizeChargeItem` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `ns3__ArrayOfChargeItem` are available:

- `ns3__ArrayOfChargeItem *soap_new_ns3__ArrayOfChargeItem(struct soap*)` managed allocation with default initialization
- `ns3__ArrayOfChargeItem *soap_new_ns3__ArrayOfChargeItem(struct soap*, int n)` managed allocation of array `ns3__ArrayOfChargeItem[n]`
- `ns3__ArrayOfChargeItem *soap_new_req_ns3__ArrayOfChargeItem(struct soap*, int __sizeChargeItem, ns3__ChargeItem **ChargeItem)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns3__ArrayOfChargeItem *soap_new_set_ns3__ArrayOfChargeItem(struct soap*, int __sizeChargeItem, ns3__ChargeItem **ChargeItem, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns3__ArrayOfChargeItem::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns3__ArrayOfChargeItem(struct soap*, const ns3__ArrayOfChargeItem*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns3__ArrayOfChargeItem(struct soap*, const char *URL, const ns3__ArrayOfChargeItem*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns3__ArrayOfChargeItem(struct soap*, const char *URL, const ns3__ArrayOfChargeItem*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns3__ArrayOfChargeItem(struct soap*, const char *URL, const ns3__ArrayOfChargeItem*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns3__ArrayOfChargeItem(struct soap*, ns3__ArrayOfChargeItem*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns3__ArrayOfChargeItem(struct soap*, const char *URL, ns3__ArrayOfChargeItem*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns3__ArrayOfChargeItem(struct soap*, ns3__ArrayOfChargeItem*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns3__ChargeItem"></a>

### `ns3__ChargeItem`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 358, is serialized as XML schema type *`ns3:ChargeItem`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns3__ChargeItem : public xsd__anyType {
      public:
        /// Optional element 'ns3:Position' of XML schema type 'xsd:long'
        LONG64 *Position;
        /// Required element 'ns3:Quantity' of XML schema type 'xsd:decimal'
        char *Quantity;
        /// Required nillable (xsi:nil when NULL) element 'ns3:Description' of XML schema type 'xsd:string'
        char *Description;
        /// Required element 'ns3:Amount' of XML schema type 'xsd:decimal'
        char *Amount;
        /// Required element 'ns3:VATRate' of XML schema type 'xsd:decimal'
        char *VATRate;
        /// Required element 'ns3:ftChargeItemCase' of XML schema type 'xsd:long'
        LONG64 ftChargeItemCase;
        /// Optional element 'ns3:ftChargeItemCaseData' of XML schema type 'xsd:string'
        char *ftChargeItemCaseData;
        /// Optional element 'ns3:VATAmount' of XML schema type 'xsd:decimal'
        char *VATAmount;
        /// Optional element 'ns3:AccountNumber' of XML schema type 'xsd:string'
        char *AccountNumber;
        /// Optional element 'ns3:CostCenter' of XML schema type 'xsd:string'
        char *CostCenter;
        /// Optional element 'ns3:ProductGroup' of XML schema type 'xsd:string'
        char *ProductGroup;
        /// Optional element 'ns3:ProductNumber' of XML schema type 'xsd:string'
        char *ProductNumber;
        /// Optional element 'ns3:ProductBarcode' of XML schema type 'xsd:string'
        char *ProductBarcode;
        /// Optional element 'ns3:Unit' of XML schema type 'xsd:string'
        char *Unit;
        /// Optional element 'ns3:UnitQuantity' of XML schema type 'xsd:decimal'
        char *UnitQuantity;
        /// Optional element 'ns3:UnitPrice' of XML schema type 'xsd:decimal'
        char *UnitPrice;
        /// Optional element 'ns3:Moment' of XML schema type 'xsd:dateTime'
        time_t *Moment;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ChargeItem
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__ChargeItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ChargeItem, default initialized and not managed by a soap context
        virtual ns3__ChargeItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__ChargeItem); }
      public:
        /// Constructor with default initializations
        ns3__ChargeItem() : Position(), Quantity(), Description(), Amount(), VATRate(), ftChargeItemCase(), ftChargeItemCaseData(), VATAmount(), AccountNumber(), CostCenter(), ProductGroup(), ProductNumber(), ProductBarcode(), Unit(), UnitQuantity(), UnitPrice(), Moment() { }
        virtual ~ns3__ChargeItem() { }
        /// Friend allocator used by soap_new_ns3__ChargeItem(struct soap*, int)
        friend SOAP_FMAC1 ns3__ChargeItem * SOAP_FMAC2 soap_instantiate_ns3__ChargeItem(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `LONG64 *Position` is an optional element *`<ns3:Position>`* of XML schema type *`xsd:long`*
- `char *Quantity` is a required element *`<ns3:Quantity>`* of XML schema type *`xsd:decimal`*, where the type of this member is <code><a href="#xsd__decimal"> xsd__decimal </a></code>
- `char *Description` is a required nillable (xsi:nil when NULL) element *`<ns3:Description>`* of XML schema type *`xsd:string`*
- `char *Amount` is a required element *`<ns3:Amount>`* of XML schema type *`xsd:decimal`*, where the type of this member is <code><a href="#xsd__decimal"> xsd__decimal </a></code>
- `char *VATRate` is a required element *`<ns3:VATRate>`* of XML schema type *`xsd:decimal`*, where the type of this member is <code><a href="#xsd__decimal"> xsd__decimal </a></code>
- `LONG64 ftChargeItemCase` is a required element *`<ns3:ftChargeItemCase>`* of XML schema type *`xsd:long`*
- `char *ftChargeItemCaseData` is an optional element *`<ns3:ftChargeItemCaseData>`* of XML schema type *`xsd:string`*
- `char *VATAmount` is an optional element *`<ns3:VATAmount>`* of XML schema type *`xsd:decimal`*, where the type of this member is <code><a href="#xsd__decimal"> xsd__decimal </a></code>
- `char *AccountNumber` is an optional element *`<ns3:AccountNumber>`* of XML schema type *`xsd:string`*
- `char *CostCenter` is an optional element *`<ns3:CostCenter>`* of XML schema type *`xsd:string`*
- `char *ProductGroup` is an optional element *`<ns3:ProductGroup>`* of XML schema type *`xsd:string`*
- `char *ProductNumber` is an optional element *`<ns3:ProductNumber>`* of XML schema type *`xsd:string`*
- `char *ProductBarcode` is an optional element *`<ns3:ProductBarcode>`* of XML schema type *`xsd:string`*
- `char *Unit` is an optional element *`<ns3:Unit>`* of XML schema type *`xsd:string`*
- `char *UnitQuantity` is an optional element *`<ns3:UnitQuantity>`* of XML schema type *`xsd:decimal`*, where the type of this member is <code><a href="#xsd__decimal"> xsd__decimal </a></code>
- `char *UnitPrice` is an optional element *`<ns3:UnitPrice>`* of XML schema type *`xsd:decimal`*, where the type of this member is <code><a href="#xsd__decimal"> xsd__decimal </a></code>
- `time_t *Moment` is an optional element *`<ns3:Moment>`* of XML schema type *`xsd:dateTime`*

The following operations on `ns3__ChargeItem` are available:

- `ns3__ChargeItem *soap_new_ns3__ChargeItem(struct soap*)` managed allocation with default initialization
- `ns3__ChargeItem *soap_new_ns3__ChargeItem(struct soap*, int n)` managed allocation of array `ns3__ChargeItem[n]`
- `ns3__ChargeItem *soap_new_req_ns3__ChargeItem(struct soap*, char *Quantity, char *Description, char *Amount, char *VATRate, LONG64 ftChargeItemCase)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns3__ChargeItem *soap_new_set_ns3__ChargeItem(struct soap*, LONG64 *Position, char *Quantity, char *Description, char *Amount, char *VATRate, LONG64 ftChargeItemCase, char *ftChargeItemCaseData, char *VATAmount, char *AccountNumber, char *CostCenter, char *ProductGroup, char *ProductNumber, char *ProductBarcode, char *Unit, char *UnitQuantity, char *UnitPrice, time_t *Moment, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns3__ChargeItem::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns3__ChargeItem(struct soap*, const ns3__ChargeItem*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns3__ChargeItem(struct soap*, const char *URL, const ns3__ChargeItem*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns3__ChargeItem(struct soap*, const char *URL, const ns3__ChargeItem*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns3__ChargeItem(struct soap*, const char *URL, const ns3__ChargeItem*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns3__ChargeItem(struct soap*, ns3__ChargeItem*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns3__ChargeItem(struct soap*, const char *URL, ns3__ChargeItem*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns3__ChargeItem(struct soap*, ns3__ChargeItem*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns3__ArrayOfPayItem"></a>

### `ns3__ArrayOfPayItem`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 360, is serialized as XML schema type *`ns3:ArrayOfPayItem`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns3__ArrayOfPayItem : public xsd__anyType {
      public:
        /// Sequence of elements 'ns3:PayItem' of XML schema type 'ns3:PayItem' stored in dynamic array PayItem of length __sizePayItem
        int __sizePayItem;
        ns3__PayItem **PayItem;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ArrayOfPayItem
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__ArrayOfPayItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ArrayOfPayItem, default initialized and not managed by a soap context
        virtual ns3__ArrayOfPayItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__ArrayOfPayItem); }
      public:
        /// Constructor with default initializations
        ns3__ArrayOfPayItem() : __sizePayItem(), PayItem() { }
        virtual ~ns3__ArrayOfPayItem() { }
        /// Friend allocator used by soap_new_ns3__ArrayOfPayItem(struct soap*, int)
        friend SOAP_FMAC1 ns3__ArrayOfPayItem * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfPayItem(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `int __sizePayItem` is a sequence of elements *`<ns3:PayItem>`* of XML schema type *`ns3:PayItem`* stored in dynamic array `PayItem` of length `__sizePayItem` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `ns3__ArrayOfPayItem` are available:

- `ns3__ArrayOfPayItem *soap_new_ns3__ArrayOfPayItem(struct soap*)` managed allocation with default initialization
- `ns3__ArrayOfPayItem *soap_new_ns3__ArrayOfPayItem(struct soap*, int n)` managed allocation of array `ns3__ArrayOfPayItem[n]`
- `ns3__ArrayOfPayItem *soap_new_req_ns3__ArrayOfPayItem(struct soap*, int __sizePayItem, ns3__PayItem **PayItem)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns3__ArrayOfPayItem *soap_new_set_ns3__ArrayOfPayItem(struct soap*, int __sizePayItem, ns3__PayItem **PayItem, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns3__ArrayOfPayItem::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns3__ArrayOfPayItem(struct soap*, const ns3__ArrayOfPayItem*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns3__ArrayOfPayItem(struct soap*, const char *URL, const ns3__ArrayOfPayItem*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns3__ArrayOfPayItem(struct soap*, const char *URL, const ns3__ArrayOfPayItem*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns3__ArrayOfPayItem(struct soap*, const char *URL, const ns3__ArrayOfPayItem*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns3__ArrayOfPayItem(struct soap*, ns3__ArrayOfPayItem*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns3__ArrayOfPayItem(struct soap*, const char *URL, ns3__ArrayOfPayItem*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns3__ArrayOfPayItem(struct soap*, ns3__ArrayOfPayItem*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns3__PayItem"></a>

### `ns3__PayItem`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 362, is serialized as XML schema type *`ns3:PayItem`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns3__PayItem : public xsd__anyType {
      public:
        /// Optional element 'ns3:Position' of XML schema type 'xsd:long'
        LONG64 *Position;
        /// Required element 'ns3:Quantity' of XML schema type 'xsd:decimal'
        char *Quantity;
        /// Required nillable (xsi:nil when NULL) element 'ns3:Description' of XML schema type 'xsd:string'
        char *Description;
        /// Required element 'ns3:Amount' of XML schema type 'xsd:decimal'
        char *Amount;
        /// Required element 'ns3:ftPayItemCase' of XML schema type 'xsd:long'
        LONG64 ftPayItemCase;
        /// Optional element 'ns3:ftPayItemCaseData' of XML schema type 'xsd:string'
        char *ftPayItemCaseData;
        /// Optional element 'ns3:AccountNumber' of XML schema type 'xsd:string'
        char *AccountNumber;
        /// Optional element 'ns3:CostCenter' of XML schema type 'xsd:string'
        char *CostCenter;
        /// Optional element 'ns3:MoneyGroup' of XML schema type 'xsd:string'
        char *MoneyGroup;
        /// Optional element 'ns3:MoneyNumber' of XML schema type 'xsd:string'
        char *MoneyNumber;
        /// Optional element 'ns3:Moment' of XML schema type 'xsd:dateTime'
        time_t *Moment;
      public:
        /// Return unique type id SOAP_TYPE_ns3__PayItem
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__PayItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__PayItem, default initialized and not managed by a soap context
        virtual ns3__PayItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__PayItem); }
      public:
        /// Constructor with default initializations
        ns3__PayItem() : Position(), Quantity(), Description(), Amount(), ftPayItemCase(), ftPayItemCaseData(), AccountNumber(), CostCenter(), MoneyGroup(), MoneyNumber(), Moment() { }
        virtual ~ns3__PayItem() { }
        /// Friend allocator used by soap_new_ns3__PayItem(struct soap*, int)
        friend SOAP_FMAC1 ns3__PayItem * SOAP_FMAC2 soap_instantiate_ns3__PayItem(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `LONG64 *Position` is an optional element *`<ns3:Position>`* of XML schema type *`xsd:long`*
- `char *Quantity` is a required element *`<ns3:Quantity>`* of XML schema type *`xsd:decimal`*, where the type of this member is <code><a href="#xsd__decimal"> xsd__decimal </a></code>
- `char *Description` is a required nillable (xsi:nil when NULL) element *`<ns3:Description>`* of XML schema type *`xsd:string`*
- `char *Amount` is a required element *`<ns3:Amount>`* of XML schema type *`xsd:decimal`*, where the type of this member is <code><a href="#xsd__decimal"> xsd__decimal </a></code>
- `LONG64 ftPayItemCase` is a required element *`<ns3:ftPayItemCase>`* of XML schema type *`xsd:long`*
- `char *ftPayItemCaseData` is an optional element *`<ns3:ftPayItemCaseData>`* of XML schema type *`xsd:string`*
- `char *AccountNumber` is an optional element *`<ns3:AccountNumber>`* of XML schema type *`xsd:string`*
- `char *CostCenter` is an optional element *`<ns3:CostCenter>`* of XML schema type *`xsd:string`*
- `char *MoneyGroup` is an optional element *`<ns3:MoneyGroup>`* of XML schema type *`xsd:string`*
- `char *MoneyNumber` is an optional element *`<ns3:MoneyNumber>`* of XML schema type *`xsd:string`*
- `time_t *Moment` is an optional element *`<ns3:Moment>`* of XML schema type *`xsd:dateTime`*

The following operations on `ns3__PayItem` are available:

- `ns3__PayItem *soap_new_ns3__PayItem(struct soap*)` managed allocation with default initialization
- `ns3__PayItem *soap_new_ns3__PayItem(struct soap*, int n)` managed allocation of array `ns3__PayItem[n]`
- `ns3__PayItem *soap_new_req_ns3__PayItem(struct soap*, char *Quantity, char *Description, char *Amount, LONG64 ftPayItemCase)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns3__PayItem *soap_new_set_ns3__PayItem(struct soap*, LONG64 *Position, char *Quantity, char *Description, char *Amount, LONG64 ftPayItemCase, char *ftPayItemCaseData, char *AccountNumber, char *CostCenter, char *MoneyGroup, char *MoneyNumber, time_t *Moment, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns3__PayItem::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns3__PayItem(struct soap*, const ns3__PayItem*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns3__PayItem(struct soap*, const char *URL, const ns3__PayItem*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns3__PayItem(struct soap*, const char *URL, const ns3__PayItem*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns3__PayItem(struct soap*, const char *URL, const ns3__PayItem*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns3__PayItem(struct soap*, ns3__PayItem*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns3__PayItem(struct soap*, const char *URL, ns3__PayItem*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns3__PayItem(struct soap*, ns3__PayItem*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns3__ReceiptResponse"></a>

### `ns3__ReceiptResponse`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 364, is serialized as XML schema type *`ns3:ReceiptResponse`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns3__ReceiptResponse : public xsd__anyType {
      public:
        /// Required nillable (xsi:nil when NULL) element 'ns3:ftCashBoxID' of XML schema type 'xsd:string'
        char *ftCashBoxID;
        /// Required nillable (xsi:nil when NULL) element 'ns3:ftQueueID' of XML schema type 'xsd:string'
        char *ftQueueID;
        /// Required nillable (xsi:nil when NULL) element 'ns3:ftQueueItemID' of XML schema type 'xsd:string'
        char *ftQueueItemID;
        /// Required element 'ns3:ftQueueRow' of XML schema type 'xsd:long'
        LONG64 ftQueueRow;
        /// Required nillable (xsi:nil when NULL) element 'ns3:cbTerminalID' of XML schema type 'xsd:string'
        char *cbTerminalID;
        /// Required nillable (xsi:nil when NULL) element 'ns3:cbReceiptReference' of XML schema type 'xsd:string'
        char *cbReceiptReference;
        /// Required nillable (xsi:nil when NULL) element 'ns3:ftCashBoxIdentification' of XML schema type 'xsd:string'
        char *ftCashBoxIdentification;
        /// Required nillable (xsi:nil when NULL) element 'ns3:ftReceiptIdentification' of XML schema type 'xsd:string'
        char *ftReceiptIdentification;
        /// Required element 'ns3:ftReceiptMoment' of XML schema type 'xsd:dateTime'
        time_t ftReceiptMoment;
        /// Optional element 'ns3:ftReceiptHeader' of XML schema type 'ns4:ArrayOfstring'
        ns4__ArrayOfstring *ftReceiptHeader;
        /// Optional element 'ns3:ftChargeItems' of XML schema type 'ns3:ArrayOfChargeItem'
        ns3__ArrayOfChargeItem *ftChargeItems;
        /// Optional element 'ns3:ftChargeLines' of XML schema type 'ns4:ArrayOfstring'
        ns4__ArrayOfstring *ftChargeLines;
        /// Optional element 'ns3:ftPayItems' of XML schema type 'ns3:ArrayOfPayItem'
        ns3__ArrayOfPayItem *ftPayItems;
        /// Optional element 'ns3:ftPayLines' of XML schema type 'ns4:ArrayOfstring'
        ns4__ArrayOfstring *ftPayLines;
        /// Required nillable (xsi:nil when NULL) element 'ns3:ftSignatures' of XML schema type 'ns3:ArrayOfSignaturItem'
        ns3__ArrayOfSignaturItem *ftSignatures;
        /// Optional element 'ns3:ftReceiptFooter' of XML schema type 'ns4:ArrayOfstring'
        ns4__ArrayOfstring *ftReceiptFooter;
        /// Required element 'ns3:ftState' of XML schema type 'xsd:long'
        LONG64 ftState;
        /// Optional element 'ns3:ftStateData' of XML schema type 'xsd:string'
        char *ftStateData;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ReceiptResponse
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__ReceiptResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ReceiptResponse, default initialized and not managed by a soap context
        virtual ns3__ReceiptResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__ReceiptResponse); }
      public:
        /// Constructor with default initializations
        ns3__ReceiptResponse() : ftCashBoxID(), ftQueueID(), ftQueueItemID(), ftQueueRow(), cbTerminalID(), cbReceiptReference(), ftCashBoxIdentification(), ftReceiptIdentification(), ftReceiptMoment(), ftReceiptHeader(), ftChargeItems(), ftChargeLines(), ftPayItems(), ftPayLines(), ftSignatures(), ftReceiptFooter(), ftState(), ftStateData() { }
        virtual ~ns3__ReceiptResponse() { }
        /// Friend allocator used by soap_new_ns3__ReceiptResponse(struct soap*, int)
        friend SOAP_FMAC1 ns3__ReceiptResponse * SOAP_FMAC2 soap_instantiate_ns3__ReceiptResponse(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `char *ftCashBoxID` is a required nillable (xsi:nil when NULL) element *`<ns3:ftCashBoxID>`* of XML schema type *`xsd:string`*
- `char *ftQueueID` is a required nillable (xsi:nil when NULL) element *`<ns3:ftQueueID>`* of XML schema type *`xsd:string`*
- `char *ftQueueItemID` is a required nillable (xsi:nil when NULL) element *`<ns3:ftQueueItemID>`* of XML schema type *`xsd:string`*
- `LONG64 ftQueueRow` is a required element *`<ns3:ftQueueRow>`* of XML schema type *`xsd:long`*
- `char *cbTerminalID` is a required nillable (xsi:nil when NULL) element *`<ns3:cbTerminalID>`* of XML schema type *`xsd:string`*
- `char *cbReceiptReference` is a required nillable (xsi:nil when NULL) element *`<ns3:cbReceiptReference>`* of XML schema type *`xsd:string`*
- `char *ftCashBoxIdentification` is a required nillable (xsi:nil when NULL) element *`<ns3:ftCashBoxIdentification>`* of XML schema type *`xsd:string`*
- `char *ftReceiptIdentification` is a required nillable (xsi:nil when NULL) element *`<ns3:ftReceiptIdentification>`* of XML schema type *`xsd:string`*
- `time_t ftReceiptMoment` is a required element *`<ns3:ftReceiptMoment>`* of XML schema type *`xsd:dateTime`*
- `ns4__ArrayOfstring *ftReceiptHeader` is an optional element *`<ns3:ftReceiptHeader>`* of XML schema type *`ns4:ArrayOfstring`*, where the type of this member is a pointer to <code><a href="#ns4__ArrayOfstring"> ns4__ArrayOfstring </a></code>
- `ns3__ArrayOfChargeItem *ftChargeItems` is an optional element *`<ns3:ftChargeItems>`* of XML schema type *`ns3:ArrayOfChargeItem`*, where the type of this member is a pointer to <code><a href="#ns3__ArrayOfChargeItem"> ns3__ArrayOfChargeItem </a></code>
- `ns4__ArrayOfstring *ftChargeLines` is an optional element *`<ns3:ftChargeLines>`* of XML schema type *`ns4:ArrayOfstring`*, where the type of this member is a pointer to <code><a href="#ns4__ArrayOfstring"> ns4__ArrayOfstring </a></code>
- `ns3__ArrayOfPayItem *ftPayItems` is an optional element *`<ns3:ftPayItems>`* of XML schema type *`ns3:ArrayOfPayItem`*, where the type of this member is a pointer to <code><a href="#ns3__ArrayOfPayItem"> ns3__ArrayOfPayItem </a></code>
- `ns4__ArrayOfstring *ftPayLines` is an optional element *`<ns3:ftPayLines>`* of XML schema type *`ns4:ArrayOfstring`*, where the type of this member is a pointer to <code><a href="#ns4__ArrayOfstring"> ns4__ArrayOfstring </a></code>
- `ns3__ArrayOfSignaturItem *ftSignatures` is a required nillable (xsi:nil when NULL) element *`<ns3:ftSignatures>`* of XML schema type *`ns3:ArrayOfSignaturItem`*, where the type of this member is a pointer to <code><a href="#ns3__ArrayOfSignaturItem"> ns3__ArrayOfSignaturItem </a></code>
- `ns4__ArrayOfstring *ftReceiptFooter` is an optional element *`<ns3:ftReceiptFooter>`* of XML schema type *`ns4:ArrayOfstring`*, where the type of this member is a pointer to <code><a href="#ns4__ArrayOfstring"> ns4__ArrayOfstring </a></code>
- `LONG64 ftState` is a required element *`<ns3:ftState>`* of XML schema type *`xsd:long`*
- `char *ftStateData` is an optional element *`<ns3:ftStateData>`* of XML schema type *`xsd:string`*

The following operations on `ns3__ReceiptResponse` are available:

- `ns3__ReceiptResponse *soap_new_ns3__ReceiptResponse(struct soap*)` managed allocation with default initialization
- `ns3__ReceiptResponse *soap_new_ns3__ReceiptResponse(struct soap*, int n)` managed allocation of array `ns3__ReceiptResponse[n]`
- `ns3__ReceiptResponse *soap_new_req_ns3__ReceiptResponse(struct soap*, char *ftCashBoxID, char *ftQueueID, char *ftQueueItemID, LONG64 ftQueueRow, char *cbTerminalID, char *cbReceiptReference, char *ftCashBoxIdentification, char *ftReceiptIdentification, time_t ftReceiptMoment, ns3__ArrayOfSignaturItem *ftSignatures, LONG64 ftState)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns3__ReceiptResponse *soap_new_set_ns3__ReceiptResponse(struct soap*, char *ftCashBoxID, char *ftQueueID, char *ftQueueItemID, LONG64 ftQueueRow, char *cbTerminalID, char *cbReceiptReference, char *ftCashBoxIdentification, char *ftReceiptIdentification, time_t ftReceiptMoment, ns4__ArrayOfstring *ftReceiptHeader, ns3__ArrayOfChargeItem *ftChargeItems, ns4__ArrayOfstring *ftChargeLines, ns3__ArrayOfPayItem *ftPayItems, ns4__ArrayOfstring *ftPayLines, ns3__ArrayOfSignaturItem *ftSignatures, ns4__ArrayOfstring *ftReceiptFooter, LONG64 ftState, char *ftStateData, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns3__ReceiptResponse::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns3__ReceiptResponse(struct soap*, const ns3__ReceiptResponse*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns3__ReceiptResponse(struct soap*, const char *URL, const ns3__ReceiptResponse*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns3__ReceiptResponse(struct soap*, const char *URL, const ns3__ReceiptResponse*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns3__ReceiptResponse(struct soap*, const char *URL, const ns3__ReceiptResponse*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns3__ReceiptResponse(struct soap*, ns3__ReceiptResponse*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns3__ReceiptResponse(struct soap*, const char *URL, ns3__ReceiptResponse*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns3__ReceiptResponse(struct soap*, ns3__ReceiptResponse*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns3__ArrayOfSignaturItem"></a>

### `ns3__ArrayOfSignaturItem`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 366, is serialized as XML schema type *`ns3:ArrayOfSignaturItem`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns3__ArrayOfSignaturItem : public xsd__anyType {
      public:
        /// Sequence of elements 'ns3:SignaturItem' of XML schema type 'ns3:SignaturItem' stored in dynamic array SignaturItem of length __sizeSignaturItem
        int __sizeSignaturItem;
        ns3__SignaturItem **SignaturItem;
      public:
        /// Return unique type id SOAP_TYPE_ns3__ArrayOfSignaturItem
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__ArrayOfSignaturItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__ArrayOfSignaturItem, default initialized and not managed by a soap context
        virtual ns3__ArrayOfSignaturItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__ArrayOfSignaturItem); }
      public:
        /// Constructor with default initializations
        ns3__ArrayOfSignaturItem() : __sizeSignaturItem(), SignaturItem() { }
        virtual ~ns3__ArrayOfSignaturItem() { }
        /// Friend allocator used by soap_new_ns3__ArrayOfSignaturItem(struct soap*, int)
        friend SOAP_FMAC1 ns3__ArrayOfSignaturItem * SOAP_FMAC2 soap_instantiate_ns3__ArrayOfSignaturItem(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `int __sizeSignaturItem` is a sequence of elements *`<ns3:SignaturItem>`* of XML schema type *`ns3:SignaturItem`* stored in dynamic array `SignaturItem` of length `__sizeSignaturItem` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `ns3__ArrayOfSignaturItem` are available:

- `ns3__ArrayOfSignaturItem *soap_new_ns3__ArrayOfSignaturItem(struct soap*)` managed allocation with default initialization
- `ns3__ArrayOfSignaturItem *soap_new_ns3__ArrayOfSignaturItem(struct soap*, int n)` managed allocation of array `ns3__ArrayOfSignaturItem[n]`
- `ns3__ArrayOfSignaturItem *soap_new_req_ns3__ArrayOfSignaturItem(struct soap*, int __sizeSignaturItem, ns3__SignaturItem **SignaturItem)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns3__ArrayOfSignaturItem *soap_new_set_ns3__ArrayOfSignaturItem(struct soap*, int __sizeSignaturItem, ns3__SignaturItem **SignaturItem, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns3__ArrayOfSignaturItem::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns3__ArrayOfSignaturItem(struct soap*, const ns3__ArrayOfSignaturItem*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns3__ArrayOfSignaturItem(struct soap*, const char *URL, const ns3__ArrayOfSignaturItem*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns3__ArrayOfSignaturItem(struct soap*, const char *URL, const ns3__ArrayOfSignaturItem*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns3__ArrayOfSignaturItem(struct soap*, const char *URL, const ns3__ArrayOfSignaturItem*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns3__ArrayOfSignaturItem(struct soap*, ns3__ArrayOfSignaturItem*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns3__ArrayOfSignaturItem(struct soap*, const char *URL, ns3__ArrayOfSignaturItem*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns3__ArrayOfSignaturItem(struct soap*, ns3__ArrayOfSignaturItem*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns3__SignaturItem"></a>

### `ns3__SignaturItem`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 368, is serialized as XML schema type *`ns3:SignaturItem`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns3__SignaturItem : public xsd__anyType {
      public:
        /// Required element 'ns3:ftSignatureFormat' of XML schema type 'xsd:long'
        LONG64 ftSignatureFormat;
        /// Required element 'ns3:ftSignatureType' of XML schema type 'xsd:long'
        LONG64 ftSignatureType;
        /// Optional element 'ns3:Caption' of XML schema type 'xsd:string'
        char *Caption;
        /// Required nillable (xsi:nil when NULL) element 'ns3:Data' of XML schema type 'xsd:string'
        char *Data;
      public:
        /// Return unique type id SOAP_TYPE_ns3__SignaturItem
        virtual long soap_type(void) const { return SOAP_TYPE_ns3__SignaturItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns3__SignaturItem, default initialized and not managed by a soap context
        virtual ns3__SignaturItem *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns3__SignaturItem); }
      public:
        /// Constructor with default initializations
        ns3__SignaturItem() : ftSignatureFormat(), ftSignatureType(), Caption(), Data() { }
        virtual ~ns3__SignaturItem() { }
        /// Friend allocator used by soap_new_ns3__SignaturItem(struct soap*, int)
        friend SOAP_FMAC1 ns3__SignaturItem * SOAP_FMAC2 soap_instantiate_ns3__SignaturItem(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `LONG64 ftSignatureFormat` is a required element *`<ns3:ftSignatureFormat>`* of XML schema type *`xsd:long`*
- `LONG64 ftSignatureType` is a required element *`<ns3:ftSignatureType>`* of XML schema type *`xsd:long`*
- `char *Caption` is an optional element *`<ns3:Caption>`* of XML schema type *`xsd:string`*
- `char *Data` is a required nillable (xsi:nil when NULL) element *`<ns3:Data>`* of XML schema type *`xsd:string`*

The following operations on `ns3__SignaturItem` are available:

- `ns3__SignaturItem *soap_new_ns3__SignaturItem(struct soap*)` managed allocation with default initialization
- `ns3__SignaturItem *soap_new_ns3__SignaturItem(struct soap*, int n)` managed allocation of array `ns3__SignaturItem[n]`
- `ns3__SignaturItem *soap_new_req_ns3__SignaturItem(struct soap*, LONG64 ftSignatureFormat, LONG64 ftSignatureType, char *Data)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns3__SignaturItem *soap_new_set_ns3__SignaturItem(struct soap*, LONG64 ftSignatureFormat, LONG64 ftSignatureType, char *Caption, char *Data, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns3__SignaturItem::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns3__SignaturItem(struct soap*, const ns3__SignaturItem*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns3__SignaturItem(struct soap*, const char *URL, const ns3__SignaturItem*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns3__SignaturItem(struct soap*, const char *URL, const ns3__SignaturItem*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns3__SignaturItem(struct soap*, const char *URL, const ns3__SignaturItem*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns3__SignaturItem(struct soap*, ns3__SignaturItem*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns3__SignaturItem(struct soap*, const char *URL, ns3__SignaturItem*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns3__SignaturItem(struct soap*, ns3__SignaturItem*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="ns4__ArrayOfstring"></a>

### `ns4__ArrayOfstring`

This class is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 370, is serialized as XML schema type *`ns4:ArrayOfstring`*, and has the following auto-completed declaration in soapStub.h:

    class SOAP_CMAC ns4__ArrayOfstring : public xsd__anyType {
      public:
        /// Sequence of elements 'ns4:string' of XML schema type 'xsd:string' stored in dynamic array string of length __sizestring
        int __sizestring;
        char **string;
      public:
        /// Return unique type id SOAP_TYPE_ns4__ArrayOfstring
        virtual long soap_type(void) const { return SOAP_TYPE_ns4__ArrayOfstring; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns4__ArrayOfstring, default initialized and not managed by a soap context
        virtual ns4__ArrayOfstring *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(ns4__ArrayOfstring); }
      public:
        /// Constructor with default initializations
        ns4__ArrayOfstring() : __sizestring(), string() { }
        virtual ~ns4__ArrayOfstring() { }
        /// Friend allocator used by soap_new_ns4__ArrayOfstring(struct soap*, int)
        friend SOAP_FMAC1 ns4__ArrayOfstring * SOAP_FMAC2 soap_instantiate_ns4__ArrayOfstring(struct soap*, int, const char*, const char*, size_t*);
    };

where:

- <code><a href="#xsd__anyType"> xsd__anyType </a></code> is the base class of this derived class
- `int __sizestring` is a sequence of elements *`<ns4:string>`* of XML schema type *`xsd:string`* stored in dynamic array `string` of length `__sizestring` (the leading underscores of the member name make this member invisible in XML, meaning it has no element tag)

The following operations on `ns4__ArrayOfstring` are available:

- `ns4__ArrayOfstring *soap_new_ns4__ArrayOfstring(struct soap*)` managed allocation with default initialization
- `ns4__ArrayOfstring *soap_new_ns4__ArrayOfstring(struct soap*, int n)` managed allocation of array `ns4__ArrayOfstring[n]`
- `ns4__ArrayOfstring *soap_new_req_ns4__ArrayOfstring(struct soap*, int __sizestring, char **string)` managed allocation with required members assigned the values of these parameters, with all other members default initialized
- `ns4__ArrayOfstring *soap_new_set_ns4__ArrayOfstring(struct soap*, int __sizestring, char **string, char *__item__1)` managed allocation with public members assigned the values of these parameters
- `void ns4__ArrayOfstring::soap_default(struct soap*)` (re)set members to default values
- `int soap_write_ns4__ArrayOfstring(struct soap*, const ns4__ArrayOfstring*)` serialize to XML, returns `SOAP_OK` or error code
- `int soap_PUT_ns4__ArrayOfstring(struct soap*, const char *URL, const ns4__ArrayOfstring*)` REST PUT XML, returns `SOAP_OK` or error code
- `int soap_PATCH_ns4__ArrayOfstring(struct soap*, const char *URL, const ns4__ArrayOfstring*)` REST PATCH XML, returns `SOAP_OK` or error code
- `int soap_POST_send_ns4__ArrayOfstring(struct soap*, const char *URL, const ns4__ArrayOfstring*)` REST POST send XML (MUST be followed by a `soap_POST_recv_Type`), returns `SOAP_OK` or error code
- `int soap_read_ns4__ArrayOfstring(struct soap*, ns4__ArrayOfstring*)` deserialize from XML, returns `SOAP_OK` or error code
- `int soap_GET_ns4__ArrayOfstring(struct soap*, const char *URL, ns4__ArrayOfstring*)` REST GET XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_ns4__ArrayOfstring(struct soap*, ns4__ArrayOfstring*)` REST POST receive XML (after a `soap_POST_send_Type`), returns `SOAP_OK` or error code

[![][1] To top](#)


<a name="__ns1__Sign"></a>

### `struct __ns1__Sign`

This struct is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 1273, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__Sign()`.

[![][1] To top](#)


<a name="__ns1__Journal"></a>

### `struct __ns1__Journal`

This struct is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 1343, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__Journal()`.

[![][1] To top](#)


<a name="__ns1__Echo"></a>

### `struct __ns1__Echo`

This struct is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 1413, is a wrapper, meaning that it wraps data and is not visible in XML and is internally used to wrap the request element(s) of the service operation `__ns1__Echo()`.

[![][1] To top](#)


<a name="SOAP_ENV__Header"></a>

### `struct SOAP_ENV__Header`

This struct is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 1648, is the SOAP protocol *`<SOAP-ENV:Header>`* element with message-specific child elements that are mandatory to process when attributed with *`mustUnderstand="true"`*.  Headers are usually added and processed by plugins.  To remove the SOAP Header when sending or returning a message, set `soap->header = NULL`.  Use `soap_header(struct soap *soap)` to allocate a `struct SOAP_ENV__Header` which will be pointed to by `soap->header`, then initialize it with `soap_default_SOAP_ENV__Header(soap, soap->header)` and set one or more of its data members (if any):

*No SOAP headers are applicable*

This struct will be auto-generated when it is not explicitly declared in an interface header file, and is declared mutable, meaning that multiple declarations in interface header files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


<a name="SOAP_ENV__Code"></a>

### `struct SOAP_ENV__Code`

This struct is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 1648, is recursive, meaning it may (in)directly reference itself through its (base or derived class) members, and is the SOAP protocol *`<SOAP-ENV:Code>`* element.  This struct is for internal use and will be auto-generated when not explicitly declared.

[![][1] To top](#)


<a name="SOAP_ENV__Detail"></a>

### `struct SOAP_ENV__Detail`

This struct is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 1648, is the SOAP protocol *`<SOAP-ENV:Detail>`* element with details returned by a service that triggered the error.  Fault details are added and processed by plugins by setting the `detail` (for SOAP 1.1) or `SOAP_ENV__Detail` (for SOAP 1.2) member of `struct SOAP_ENV__Fault` and then setting one ore more of the detail members:

- `char *__any` catch-all XML in literal XML string, see also <code><a href="#_XML"> _XML </a></code>
- `int __type` element *`<fault>`* serialized with C/C++ type `__type` = `SOAP_TYPE_<Type>`


This struct will be auto-generated when it is not explicitly declared in an interface header file, and is declared mutable, meaning that multiple declarations in interface header files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_<typename> assigned to __type */
        /** Do not create a cyclic data structure through this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


<a name="SOAP_ENV__Reason"></a>

### `struct SOAP_ENV__Reason`

This struct is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 1648, is the SOAP protocol *`<SOAP-ENV:Reason>`* element.  This struct is for internal use and will be auto-generated when not explicitly declared.

[![][1] To top](#)


<a name="SOAP_ENV__Fault"></a>

### `struct SOAP_ENV__Fault`

This struct is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 1648, is the SOAP protocol *`<SOAP-ENV:Fault>`* element with fault information and details returned by a service that triggered the error.  At the server side, a fault can be explicitly set within a service operation by calling and returning:

- `int soap_sender_fault(struct soap *soap, const char *faultstring, const char *XML)` return this error code when the sender is at fault (irrecoverable)
- `int soap_receiver_fault(struct soap *soap, const char *faultstring, const char *XML)` return this error code when the receiver is at fault (recoverable, sender may retry)

A service operation may also return an HTTP status or error code (200 to 599).

At the client side the (proxy) call returns the error code which is also stored in `soap->error`.  The fault structure is pointed to by `soap->fault`.  The fault can be displayed with:

- `void soap_print_fault(struct soap *soap, FILE *fd)` display fault
- `void soap_print_fault_location(struct soap *soap, FILE *fd)` display the location of the fault in the XML message that caused it
- `void soap_sprint_fault(struct soap *soap, char *buf, size_t len)` write fault to buffer
- `void soap_stream_fault(struct soap *soap, std::ostream&)` write fault to stream
- `const char *soap_fault_subcode(struct soap *soap)` returns the SOAP Fault subcode QName string or NULL when absent
- `const char *soap_fault_string(struct soap *soap)` returns the SOAP Fault string/reason or NULL when absent
- `const char *soap_fault_detail(struct soap *soap)` returns the SOAP Fault detail XML string or NULL when absent
- `const char **soap_faultsubcode(struct soap *soap)` returns a pointer to the SOAP Fault to set this QName string
- `const char **soap_faultstring(struct soap *soap)` returns a pointer to the SOAP Fault string/reason to set this string
- `const char **soap_faultdetail(struct soap *soap)` returns a pointer to the SOAP Fault detail XML string to set this string or returns NULL when not accessible

This struct will be auto-generated when it is not explicitly declared in an interface header file and is declared mutable, meaning that multiple declarations in interface header files are collected into one structure, and has the following auto-completed declaration in soapStub.h:

    struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
    };

[![][1] To top](#)


## Typedefs {#doc-typedefs}

A typedef type is serializable if its underlying base type is serializable.  Typedefs may declare custom serializers, meaning their underlying types are custom-serialized in XML using serialization rules that differ from the serialization rules of the underlying base type:
<table class="doxtable">
<tr><th> Typedef </th><th> Type </th><th> Declared </th><th> Serializable </th><th> Custom </th></tr>
<tr><td><code><a href="#_XML"> _XML </a></code></td><td><code> char * </code></td><td> (built-in):0 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#_QName"> _QName </a></code></td><td><code> char * </code></td><td> (built-in):0 </td><td> yes </td><td> yes </td></tr>
<tr><td><code><a href="#xsd__byte"> xsd__byte </a></code></td><td><code> char </code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:174 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__unsignedByte"> xsd__unsignedByte </a></code></td><td><code> unsigned char </code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:177 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__ID"> xsd__ID </a></code></td><td><code> char * </code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:180 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__IDREF"> xsd__IDREF </a></code></td><td><code> char * </code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:190 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__anyURI"> xsd__anyURI </a></code></td><td><code> char * </code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:207 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__decimal"> xsd__decimal </a></code></td><td><code> char * </code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:245 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#xsd__duration"> xsd__duration </a></code></td><td><code> char * </code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:262 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#ns2__char"> ns2__char </a></code></td><td><code> int </code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:414 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#ns2__duration"> ns2__duration </a></code></td><td><code> char * </code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:428 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#ns2__guid"> ns2__guid </a></code></td><td><code> char * </code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:441 </td><td> yes </td><td>  </td></tr>
<tr><td><code><a href="#ns5__StreamBody"> ns5__StreamBody </a></code></td><td><code> xsd__base64Binary </code></td><td> .\lib\gsoap\gsoap\bin\win32\ftservice.h:477 </td><td> yes </td><td>  </td></tr>
</table>

<a name="_XML"></a>

### `_XML`

This typedef is internally generated and is a built-in string type to hold XML that is literally serialized to and from XML

[![][1] To top](#)


<a name="_QName"></a>

### `_QName`

This typedef is internally generated and is a built-in string type to serialize a list of space-separated qualified names (*`xsd:QName`*), such that XML namespace prefixes are normalized to the XML prefixes defined in the [namespace table](#doc-namespaces) or replaced with "URI": when the namespace table has no prefix entry for the URI

[![][1] To top](#)


<a name="xsd__byte"></a>

### `xsd__byte`

This typedef is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 174, is serialized as XML schema type *`xsd:byte`* and has underlying base type `char`

[![][1] To top](#)


<a name="xsd__unsignedByte"></a>

### `xsd__unsignedByte`

This typedef is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 177, is serialized as XML schema type *`xsd:unsignedByte`* and has underlying base type `unsigned char`

[![][1] To top](#)


<a name="xsd__ID"></a>

### `xsd__ID`

This typedef is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 180, is serialized as XML schema type *`xsd:ID`* and has underlying base type `char *`, which should be

- matching regex pattern "[\i-[:]][\c-[:]]*"

[![][1] To top](#)


<a name="xsd__IDREF"></a>

### `xsd__IDREF`

This typedef is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 190, is serialized as XML schema type *`xsd:IDREF`* and has underlying base type `char *`, which should be

- matching regex pattern "[\i-[:]][\c-[:]]*"

[![][1] To top](#)


<a name="xsd__anyURI"></a>

### `xsd__anyURI`

This typedef is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 207, is serialized as XML schema type *`xsd:anyURI`* and has underlying base type `char *`

[![][1] To top](#)


<a name="xsd__decimal"></a>

### `xsd__decimal`

This typedef is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 245, is serialized as XML schema type *`xsd:decimal`* and has underlying base type `char *`, which should be

- matching regex pattern "[-+]?(\d+|\d*\.\d*)"

[![][1] To top](#)


<a name="xsd__duration"></a>

### `xsd__duration`

This typedef is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 262, is serialized as XML schema type *`xsd:duration`* and has underlying base type `char *`, which should be

- matching regex pattern "[-+]?P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+(\.\d*)?S)?)?"

[![][1] To top](#)


<a name="ns2__char"></a>

### `ns2__char`

This typedef is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 414, is serialized as XML schema type *`ns2:char`* and has underlying base type `int`

[![][1] To top](#)


<a name="ns2__duration"></a>

### `ns2__duration`

This typedef is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 428, is serialized as XML schema type *`ns2:duration`* and has underlying base type `char *`, which should be

- matching regex pattern "\-?P(\d*D)?(T(\d*H)?(\d*M)?(\d*(\.\d*)?S)?)?"

[![][1] To top](#)


<a name="ns2__guid"></a>

### `ns2__guid`

This typedef is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 441, is serialized as XML schema type *`ns2:guid`* and has underlying base type `char *`, which should be

- matching regex pattern "[\da-fA-F]{8}-[\da-fA-F]{4}-[\da-fA-F]{4}-[\da-fA-F]{4}-[\da-fA-F]{12}"

[![][1] To top](#)


<a name="ns5__StreamBody"></a>

### `ns5__StreamBody`

This typedef is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 477, is serialized as XML schema type *`ns5:StreamBody`* and has underlying base type `xsd__base64Binary`

[![][1] To top](#)


## Summary of Serializable Types {#doc-types}

Each serializable C/C++ *Type* with binding name *Name* has a set of auto-generated functions:

- `Type *soap_new_Name(struct soap*)` managed allocation and default initialization
- `Type *soap_new_Name(struct soap*, int n)` managed allocation and default initialization of an array `Type[n]`
- `void soap_default_Name(struct soap*, Type*)` initialize or reset non-class *Type* to default)
- `void Type::soap_default(struct soap*)` non-volatile class *Type* reset to default
- `Type *soap_dup_Name(struct soap*, Type *dst, const Type *src)` requires soapcpp2 option -Ec, deep copy `src` to `dst` managed by context or unmanaged when context is NULL, returning `dst` (if `dst` is NULL then allocates `dst` copy)
- `void soap_del_Name(struct soap*, Type*)` requires soapcpp2 option -Ec, deep delete *Type* which must be unmanaged
- `const char *soap_Name2s(struct soap*, Type)` primitive *Type* only, returns string-converted *Type* in temporary string buffer
- `int soap_s2Name(struct soap*, const char*, Type*)` primitive *Type* only, convert string to value, returns `SOAP_OK` or error code
- `int soap_write_Name(struct soap*, const Type*)` serialize *Type* to XML, returns `SOAP_OK` or error code
- `int soap_PUT_Name(struct soap*, const char *URL, const Type*)` REST PUT *Type* in XML, returns `SOAP_OK` or error code
- `int soap_PATCH_Name(struct soap*, const char *URL, const Type*)` REST PATCH *Type* in XML, returns `SOAP_OK` or error code
- `int soap_POST_send_Name(struct soap*, const char *URL, const Type*)` REST POST send *Type* in XML (MUST be followed by a `soap_POST_recv_OtherName`), returns `SOAP_OK` or error code
- `int soap_read_Name(struct soap*, Type*)` deserialize *Type* from XML, returns `SOAP_OK` or error code
- `int soap_GET_Name(struct soap*, const char *URL, Type*)` REST GET *Type* from XML, returns `SOAP_OK` or error code
- `int soap_POST_recv_Name(struct soap*, Type*)` REST GET *Type* from XML (after a `soap_POST_send_OtherName`), returns `SOAP_OK` or error code
- `(Type *)soap_malloc(struct soap*, sizeof(Type))` raw managed allocation of primitive *Type* (types that are not structs or classes) without initialization
- `const char *soap_strdup(struct soap*, const char*)` managed allocation and duplication of string
- `const wchar_t *soap_wstrdup(struct soap*, const wchar_t*)` managed allocation and duplication of wide string

Each *Type* also has a unique type id `SOAP_TYPE_<Type>` that you can use to serialize `void*` in a struct/class by setting the `int __type` member to this type id. The unique type id is also used to distinguish derived class instances from base class instances by calling their `virtual soap_type()` methods that return this type id.

From the toolkit documentation:

- Set `soap->sendfd = fd` to serialize to an `int fd` file descriptor
- Set `soap->os = &os` to serialize to a `std::ostream os`
- Set `soap->recvfd = fd` to deserialize from an `int fd` file descriptor
- Set `soap->is = &is` to deserialize from a `std::istream`
- All managed allocated data is deleted by `soap_destroy(soap)` followed by `soap_end(soap)` with context `soap`

The table below lists the serializable types by *Type*, binding *Name*, *Kind*, and the XSD data binding type and/or element.  Pointers, arrays, and containers of these types are also serializable:

<table class="doxtable">
<tr><th> C/C++ Type </th><th> Name </th><th> Kind </th><th> XML schema name </th></tr>
<tr><td><code><a href="#xsd__byte"> xsd__byte </a></code></td><td><code> xsd__byte </code></td><td> char </td><td> xsd:byte </td></tr>
<tr><td><code> char </code></td><td><code> byte </code></td><td> char </td><td> xsd:byte </td></tr>
<tr><td><code> short </code></td><td><code> short </code></td><td> short </td><td> xsd:short </td></tr>
<tr><td><code><a href="#ns2__char"> ns2__char </a></code></td><td><code> ns2__char </code></td><td> int </td><td> ns2:char </td></tr>
<tr><td><code> int </code></td><td><code> int </code></td><td> int </td><td> xsd:int </td></tr>
<tr><td><code> LONG64 </code></td><td><code> LONG64 </code></td><td> LONG64 </td><td> xsd:long </td></tr>
<tr><td><code> float </code></td><td><code> float </code></td><td> float </td><td> xsd:float </td></tr>
<tr><td><code> double </code></td><td><code> double </code></td><td> double </td><td> xsd:double </td></tr>
<tr><td><code><a href="#xsd__unsignedByte"> xsd__unsignedByte </a></code></td><td><code> xsd__unsignedByte </code></td><td> unsigned char </td><td> xsd:unsignedByte </td></tr>
<tr><td><code> unsigned char </code></td><td><code> unsignedByte </code></td><td> unsigned char </td><td> xsd:unsignedByte </td></tr>
<tr><td><code> unsigned short </code></td><td><code> unsignedShort </code></td><td> unsigned short </td><td> xsd:unsignedShort </td></tr>
<tr><td><code> unsigned int </code></td><td><code> unsignedInt </code></td><td> unsigned int </td><td> xsd:unsignedInt </td></tr>
<tr><td><code> ULONG64 </code></td><td><code> ULONG64 </code></td><td> ULONG64 </td><td> xsd:unsignedLong </td></tr>
<tr><td><code> time_t </code></td><td><code> dateTime </code></td><td> time_t </td><td> xsd:dateTime </td></tr>
<tr><td><code><a href="#bool"> bool </a></code></td><td><code> bool </code></td><td> bool </td><td> xsd:boolean </td></tr>
<tr><td><code><a href="#ns5__StreamBody__"> ns5__StreamBody__ </a></code></td><td><code> ns5__StreamBody__ </code></td><td> class </td><td> ns5:StreamBody </td></tr>
<tr><td><code><a href="#ns5__StreamBody"> ns5__StreamBody </a></code></td><td><code> ns5__StreamBody </code></td><td> base64 binary or attachment </td><td> ns5:StreamBody </td></tr>
<tr><td><code><a href="#ns2__guid__"> ns2__guid__ </a></code></td><td><code> ns2__guid__ </code></td><td> class </td><td> ns2:guid </td></tr>
<tr><td><code><a href="#ns2__duration__"> ns2__duration__ </a></code></td><td><code> ns2__duration__ </code></td><td> class </td><td> ns2:duration </td></tr>
<tr><td><code><a href="#ns2__char__"> ns2__char__ </a></code></td><td><code> ns2__char__ </code></td><td> class </td><td> ns2:char </td></tr>
<tr><td><code><a href="#ns4__ArrayOfstring"> ns4__ArrayOfstring </a></code></td><td><code> ns4__ArrayOfstring </code></td><td> class </td><td> ns4:ArrayOfstring </td></tr>
<tr><td><code><a href="#ns3__SignaturItem"> ns3__SignaturItem </a></code></td><td><code> ns3__SignaturItem </code></td><td> class </td><td> ns3:SignaturItem </td></tr>
<tr><td><code><a href="#ns3__ArrayOfSignaturItem"> ns3__ArrayOfSignaturItem </a></code></td><td><code> ns3__ArrayOfSignaturItem </code></td><td> class </td><td> ns3:ArrayOfSignaturItem </td></tr>
<tr><td><code><a href="#ns3__ReceiptResponse"> ns3__ReceiptResponse </a></code></td><td><code> ns3__ReceiptResponse </code></td><td> class </td><td> ns3:ReceiptResponse </td></tr>
<tr><td><code><a href="#ns3__PayItem"> ns3__PayItem </a></code></td><td><code> ns3__PayItem </code></td><td> class </td><td> ns3:PayItem </td></tr>
<tr><td><code><a href="#ns3__ArrayOfPayItem"> ns3__ArrayOfPayItem </a></code></td><td><code> ns3__ArrayOfPayItem </code></td><td> class </td><td> ns3:ArrayOfPayItem </td></tr>
<tr><td><code><a href="#ns3__ChargeItem"> ns3__ChargeItem </a></code></td><td><code> ns3__ChargeItem </code></td><td> class </td><td> ns3:ChargeItem </td></tr>
<tr><td><code><a href="#ns3__ArrayOfChargeItem"> ns3__ArrayOfChargeItem </a></code></td><td><code> ns3__ArrayOfChargeItem </code></td><td> class </td><td> ns3:ArrayOfChargeItem </td></tr>
<tr><td><code><a href="#ns3__ReceiptRequest"> ns3__ReceiptRequest </a></code></td><td><code> ns3__ReceiptRequest </code></td><td> class </td><td> ns3:ReceiptRequest </td></tr>
<tr><td><code><a href="#_ns1__EchoResponse"> _ns1__EchoResponse </a></code></td><td><code> _ns1__EchoResponse </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns1__Echo"> _ns1__Echo </a></code></td><td><code> _ns1__Echo </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns1__JournalResponse"> _ns1__JournalResponse </a></code></td><td><code> _ns1__JournalResponse </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns1__Journal"> _ns1__Journal </a></code></td><td><code> _ns1__Journal </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns1__SignResponse"> _ns1__SignResponse </a></code></td><td><code> _ns1__SignResponse </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#_ns1__Sign"> _ns1__Sign </a></code></td><td><code> _ns1__Sign </code></td><td> class </td><td>  </td></tr>
<tr><td><code><a href="#xsd__unsignedShort_"> xsd__unsignedShort_ </a></code></td><td><code> xsd__unsignedShort_ </code></td><td> class </td><td> xsd:unsignedShort </td></tr>
<tr><td><code><a href="#xsd__unsignedLong_"> xsd__unsignedLong_ </a></code></td><td><code> xsd__unsignedLong_ </code></td><td> class </td><td> xsd:unsignedLong </td></tr>
<tr><td><code><a href="#xsd__unsignedInt_"> xsd__unsignedInt_ </a></code></td><td><code> xsd__unsignedInt_ </code></td><td> class </td><td> xsd:unsignedInt </td></tr>
<tr><td><code><a href="#xsd__unsignedByte__"> xsd__unsignedByte__ </a></code></td><td><code> xsd__unsignedByte__ </code></td><td> class </td><td> xsd:unsignedByte </td></tr>
<tr><td><code><a href="#xsd__string_"> xsd__string_ </a></code></td><td><code> xsd__string_ </code></td><td> class </td><td> xsd:string </td></tr>
<tr><td><code><a href="#xsd__short_"> xsd__short_ </a></code></td><td><code> xsd__short_ </code></td><td> class </td><td> xsd:short </td></tr>
<tr><td><code><a href="#xsd__long_"> xsd__long_ </a></code></td><td><code> xsd__long_ </code></td><td> class </td><td> xsd:long </td></tr>
<tr><td><code><a href="#xsd__int_"> xsd__int_ </a></code></td><td><code> xsd__int_ </code></td><td> class </td><td> xsd:int </td></tr>
<tr><td><code><a href="#xsd__float_"> xsd__float_ </a></code></td><td><code> xsd__float_ </code></td><td> class </td><td> xsd:float </td></tr>
<tr><td><code><a href="#xsd__duration__"> xsd__duration__ </a></code></td><td><code> xsd__duration__ </code></td><td> class </td><td> xsd:duration </td></tr>
<tr><td><code><a href="#xsd__double_"> xsd__double_ </a></code></td><td><code> xsd__double_ </code></td><td> class </td><td> xsd:double </td></tr>
<tr><td><code><a href="#xsd__decimal__"> xsd__decimal__ </a></code></td><td><code> xsd__decimal__ </code></td><td> class </td><td> xsd:decimal </td></tr>
<tr><td><code><a href="#xsd__dateTime_"> xsd__dateTime_ </a></code></td><td><code> xsd__dateTime_ </code></td><td> class </td><td> xsd:dateTime </td></tr>
<tr><td><code><a href="#xsd__byte__"> xsd__byte__ </a></code></td><td><code> xsd__byte__ </code></td><td> class </td><td> xsd:byte </td></tr>
<tr><td><code><a href="#xsd__boolean_"> xsd__boolean_ </a></code></td><td><code> xsd__boolean_ </code></td><td> class </td><td> xsd:boolean </td></tr>
<tr><td><code><a href="#xsd__base64Binary__"> xsd__base64Binary__ </a></code></td><td><code> xsd__base64Binary__ </code></td><td> class </td><td> xsd:base64Binary </td></tr>
<tr><td><code><a href="#xsd__anyURI__"> xsd__anyURI__ </a></code></td><td><code> xsd__anyURI__ </code></td><td> class </td><td> xsd:anyURI </td></tr>
<tr><td><code><a href="#xsd__QName_"> xsd__QName_ </a></code></td><td><code> xsd__QName_ </code></td><td> class </td><td> xsd:QName </td></tr>
<tr><td><code><a href="#xsd__IDREF__"> xsd__IDREF__ </a></code></td><td><code> xsd__IDREF__ </code></td><td> class </td><td> xsd:IDREF </td></tr>
<tr><td><code><a href="#xsd__ID__"> xsd__ID__ </a></code></td><td><code> xsd__ID__ </code></td><td> class </td><td> xsd:ID </td></tr>
<tr><td><code><a href="#xsd__base64Binary"> xsd__base64Binary </a></code></td><td><code> xsd__base64Binary </code></td><td> base64 binary or attachment </td><td> xsd:base64Binary </td></tr>
<tr><td><code><a href="#xsd__anyType"> xsd__anyType </a></code></td><td><code> xsd__anyType </code></td><td> class </td><td> xsd:anyType </td></tr>
<tr><td><code><a href="#SOAP_ENV__Fault"> struct SOAP_ENV__Fault </a></code></td><td><code> SOAP_ENV__Fault </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Reason"> struct SOAP_ENV__Reason </a></code></td><td><code> SOAP_ENV__Reason </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Detail"> struct SOAP_ENV__Detail </a></code></td><td><code> SOAP_ENV__Detail </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Code"> struct SOAP_ENV__Code </a></code></td><td><code> SOAP_ENV__Code </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#SOAP_ENV__Header"> struct SOAP_ENV__Header </a></code></td><td><code> SOAP_ENV__Header </code></td><td> struct </td><td>  </td></tr>
<tr><td><code><a href="#ns2__guid"> ns2__guid </a></code></td><td><code> ns2__guid </code></td><td> string </td><td> ns2:guid </td></tr>
<tr><td><code><a href="#ns2__duration"> ns2__duration </a></code></td><td><code> ns2__duration </code></td><td> string </td><td> ns2:duration </td></tr>
<tr><td><code><a href="#xsd__duration"> xsd__duration </a></code></td><td><code> xsd__duration </code></td><td> string </td><td> xsd:duration </td></tr>
<tr><td><code><a href="#xsd__decimal"> xsd__decimal </a></code></td><td><code> xsd__decimal </code></td><td> string </td><td> xsd:decimal </td></tr>
<tr><td><code><a href="#xsd__anyURI"> xsd__anyURI </a></code></td><td><code> xsd__anyURI </code></td><td> string </td><td> xsd:anyURI </td></tr>
<tr><td><code><a href="#xsd__IDREF"> xsd__IDREF </a></code></td><td><code> xsd__IDREF </code></td><td> string </td><td> xsd:IDREF </td></tr>
<tr><td><code><a href="#xsd__ID"> xsd__ID </a></code></td><td><code> xsd__ID </code></td><td> string </td><td> xsd:ID </td></tr>
<tr><td><code><a href="#_QName"> _QName </a></code></td><td><code> _QName </code></td><td> string </td><td> xsd:QName </td></tr>
<tr><td><code><a href="#_XML"> _XML </a></code></td><td><code> _XML </code></td><td> string </td><td> (literal XML string) </td></tr>
<tr><td><code> char * </code></td><td><code> string </code></td><td> string </td><td> xsd:string </td></tr>
</table>

[![][1] To top](#)


## Schemas and Namespaces {#doc-namespaces}

The following schemas and namespaces are used in addition to the predefined SOAP and built-in XSD namespaces:

- Prefix `ns3` is bound to namespace URI *`http://schemas.datacontract.org/2004/07/fiskaltrust.ifPOS.v0`* with local element form default *`qualified`* and attribute form default *`unqualified`*
- Prefix `ns4` is bound to namespace URI *`http://schemas.microsoft.com/2003/10/Serialization/Arrays`* with local element form default *`qualified`* and attribute form default *`unqualified`*
- Prefix `ns2` is bound to namespace URI *`http://schemas.microsoft.com/2003/10/Serialization/`* with local element form default *`qualified`* and attribute form default *`unqualified`*
- Prefix `ns5` is bound to namespace URI *`http://schemas.microsoft.com/Message`* with local element form default *`qualified`* and attribute form default *`unqualified`*
- Prefix `ns1` is bound to namespace URI *`http://tempuri.org/`* with local element form default *`qualified`* and attribute form default *`unqualified`*


The following namespace table is saved to .\lib\gsoap\gsoap\bin\win32\BasicHttpBinding_USCOREIPOS.nsmap:

    struct Namespace namespaces[] = {
        { "SOAP-ENV", "http://schemas.xmlsoap.org/soap/envelope/", "http://schemas.xmlsoap.org/soap/envelope/", NULL },
        { "SOAP-ENC", "http://schemas.xmlsoap.org/soap/encoding/", "http://schemas.xmlsoap.org/soap/encoding/", NULL },
        { "xsi", "http://www.w3.org/2001/XMLSchema-instance", "http://www.w3.org/*/XMLSchema-instance", NULL },
        { "xsd", "http://www.w3.org/2001/XMLSchema", "http://www.w3.org/*/XMLSchema", NULL },
        { "ns3", "http://schemas.datacontract.org/2004/07/fiskaltrust.ifPOS.v0", NULL, NULL },
        { "ns4", "http://schemas.microsoft.com/2003/10/Serialization/Arrays", NULL, NULL },
        { "ns2", "http://schemas.microsoft.com/2003/10/Serialization/", NULL, NULL },
        { "ns5", "http://schemas.microsoft.com/Message", NULL, NULL },
        { "ns1", "http://tempuri.org/", NULL, NULL },
        { NULL, NULL, NULL, NULL}
    };

The table binds XML namespace prefixes (first column) to namespace URIs (second column), similar to xmlns:prefix="URI" in XML.  The third column is a URI pattern with `*` wildcards that is also accepted as a valid namespace URI for inbound XML messages.  The fourth column is NULL.  This table is globally defined for the gSOAP engine.  The engine context will look for it unless you compiled the gSOAP source codes with `-DWITH_NONAMESPACES`.  You must assign this or another namespace table with `soap_set_namespaces(struct soap *soap, struct Namespace *namespaces)` after initializing the context and before processing XML.

[![][1] To top](#)


## Web Client Operations {#doc-client}

### Operation `__ns1__Sign()`

This service operation is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 1270 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action "http://tempuri.org/IPOS/Sign"
- SOAP response action "http://tempuri.org/IPOS/SignResponse"
- Default service endpoint URL "http://localhost:1200/fiskaltrust"
- Operation namespace prefix `ns1` and URI "[http://tempuri.org/](#doc-namespaces)"

To invoke this service operation, use the following auto-generated function declared in [soapStub.h](.\lib\gsoap\gsoap\bin\win32\soapStub.h) and defined in [soapClient.cpp](.\lib\gsoap\gsoap\bin\win32\soapClient.cpp):

    
    /** Web service synchronous operation 'soap_call___ns1__Sign' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Sign(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Sign *ns1__Sign, _ns1__SignResponse &ns1__SignResponse);
    /** Web service asynchronous operation 'soap_send___ns1__Sign' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__Sign(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Sign *ns1__Sign);
    /** Web service asynchronous operation 'soap_recv___ns1__Sign' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__Sign(struct soap *soap, _ns1__SignResponse &ns1__SignResponse);

where:

- `struct soap *soap` is the context
- `const char *soap_endpoint` is the endpoint URL (or list of space-separated URLs) or NULL to use the default endpoint(s)
- `const char *soap_action` is the SOAP action header or NULL to use the default action (recommended)
- `_ns1__Sign *ns1__Sign` is optional, where the type of this parameter is a pointer to <code><a href="#_ns1__Sign"> _ns1__Sign </a></code>
- `_ns1__SignResponse &ns1__SignResponse` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#_ns1__SignResponse"> _ns1__SignResponse </a></code>

The `soap_call___ns1__Sign` function sends the request message and receives the response message, assigning the last parameter `ns1__SignResponse` the response value received. The `soap_send___ns1__Sign` function sends the request message and the `soap_recv___ns1__Sign` function receives the response message asynchronously. These functions return `SOAP_OK` or an error code.

[![][1] To top](#)


### Operation `__ns1__Journal()`

This service operation is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 1340 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action "http://tempuri.org/IPOS/Journal"
- SOAP response action "http://tempuri.org/IPOS/JournalResponse"
- Default service endpoint URL "http://localhost:1200/fiskaltrust"
- Operation namespace prefix `ns1` and URI "[http://tempuri.org/](#doc-namespaces)"

To invoke this service operation, use the following auto-generated function declared in [soapStub.h](.\lib\gsoap\gsoap\bin\win32\soapStub.h) and defined in [soapClient.cpp](.\lib\gsoap\gsoap\bin\win32\soapClient.cpp):

    
    /** Web service synchronous operation 'soap_call___ns1__Journal' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Journal(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Journal *ns1__Journal, _ns1__JournalResponse &ns1__JournalResponse);
    /** Web service asynchronous operation 'soap_send___ns1__Journal' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__Journal(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Journal *ns1__Journal);
    /** Web service asynchronous operation 'soap_recv___ns1__Journal' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__Journal(struct soap *soap, _ns1__JournalResponse &ns1__JournalResponse);

where:

- `struct soap *soap` is the context
- `const char *soap_endpoint` is the endpoint URL (or list of space-separated URLs) or NULL to use the default endpoint(s)
- `const char *soap_action` is the SOAP action header or NULL to use the default action (recommended)
- `_ns1__Journal *ns1__Journal` is optional, where the type of this parameter is a pointer to <code><a href="#_ns1__Journal"> _ns1__Journal </a></code>
- `_ns1__JournalResponse &ns1__JournalResponse` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#_ns1__JournalResponse"> _ns1__JournalResponse </a></code>

The `soap_call___ns1__Journal` function sends the request message and receives the response message, assigning the last parameter `ns1__JournalResponse` the response value received. The `soap_send___ns1__Journal` function sends the request message and the `soap_recv___ns1__Journal` function receives the response message asynchronously. These functions return `SOAP_OK` or an error code.

[![][1] To top](#)


### Operation `__ns1__Echo()`

This service operation is declared in [.\lib\gsoap\gsoap\bin\win32\ftservice.h](.\lib\gsoap\gsoap\bin\win32\ftservice.h) at line 1410 and has the following properties:

- SOAP 1.1 protocol
- SOAP document style
- SOAP literal
- SOAP action "http://tempuri.org/IPOS/Echo"
- SOAP response action "http://tempuri.org/IPOS/EchoResponse"
- Default service endpoint URL "http://localhost:1200/fiskaltrust"
- Operation namespace prefix `ns1` and URI "[http://tempuri.org/](#doc-namespaces)"

To invoke this service operation, use the following auto-generated function declared in [soapStub.h](.\lib\gsoap\gsoap\bin\win32\soapStub.h) and defined in [soapClient.cpp](.\lib\gsoap\gsoap\bin\win32\soapClient.cpp):

    
    /** Web service synchronous operation 'soap_call___ns1__Echo' to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__Echo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Echo *ns1__Echo, _ns1__EchoResponse &ns1__EchoResponse);
    /** Web service asynchronous operation 'soap_send___ns1__Echo' to send a request message to the specified endpoint and SOAP Action header, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_send___ns1__Echo(struct soap *soap, const char *soap_endpoint, const char *soap_action, _ns1__Echo *ns1__Echo);
    /** Web service asynchronous operation 'soap_recv___ns1__Echo' to receive a response message from the connected endpoint, returns SOAP_OK or error code */
    SOAP_FMAC5 int SOAP_FMAC6 soap_recv___ns1__Echo(struct soap *soap, _ns1__EchoResponse &ns1__EchoResponse);

where:

- `struct soap *soap` is the context
- `const char *soap_endpoint` is the endpoint URL (or list of space-separated URLs) or NULL to use the default endpoint(s)
- `const char *soap_action` is the SOAP action header or NULL to use the default action (recommended)
- `_ns1__Echo *ns1__Echo` is optional, where the type of this parameter is a pointer to <code><a href="#_ns1__Echo"> _ns1__Echo </a></code>
- `_ns1__EchoResponse &ns1__EchoResponse` is the service operation response data populated by the service operation, where the type of this result parameter is <code><a href="#_ns1__EchoResponse"> _ns1__EchoResponse </a></code>

The `soap_call___ns1__Echo` function sends the request message and receives the response message, assigning the last parameter `ns1__EchoResponse` the response value received. The `soap_send___ns1__Echo` function sends the request message and the `soap_recv___ns1__Echo` function receives the response message asynchronously. These functions return `SOAP_OK` or an error code.

[![][1] To top](#)



  [1]: https://www.genivia.com/images/go-up.png

--------------------------------------------------------------------------------

_Generated on Thu Jan 02 2020 12:43:47 UTC by soapcpp2 v2.8.96 for .\lib\gsoap\gsoap\bin\win32\ftservice.h._
_The gSOAP XML Web services tools are Copyright (C) Robert van Engelen, Genivia Inc. All Rights Reserved._
